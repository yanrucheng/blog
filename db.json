{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/constrained-subsequence-sum.md","hash":"3cec77c72e017ffebd610a3f55265fddefcb579c","modified":1597996657052},{"_id":"source/_posts/construct-target-array-with-multiple-sums.md","hash":"c3b1e72863c31e6f07f685e8e419e7d6aef276b7","modified":1597996657052},{"_id":"source/_posts/count-all-valid-pickup-and-delivery-options.md","hash":"38983f55993103a84273b3cb8644ee574e963a37","modified":1597996657052},{"_id":"source/_posts/find-a-value-of-a-mysterious-function-closest-to-target.md","hash":"60d1b2d53c0cb9d4546246e71cffd3945ec2eed6","modified":1597996657053},{"_id":"source/_posts/frog-position-after-t-seconds.md","hash":"418a30132d2a2c5e8bc1c13ea8e227512e72f485","modified":1597996657053},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1597995157468},{"_id":"source/_posts/largest-divisible-subset.md","hash":"d765a23b55679e98f6f7d823390a79977dcfb20f","modified":1597996657053},{"_id":"source/_posts/longest-happy-prefix.md","hash":"458395b9bf89f38dc13d134fe0d29338f2fe65df","modified":1597996657054},{"_id":"source/_posts/max-dot-product-of-two-subsequences.md","hash":"583247dd056b9197bf4c5058a01adc90583200d3","modified":1597996657054},{"_id":"source/_posts/maximum-number-of-non-overlapping-substrings.md","hash":"f20083dcf5a9f220018ff93a41151ec0ebacb326","modified":1597996657054},{"_id":"source/_posts/maximum-students-taking-exam.md","hash":"800b5ebf43a47eb9e10125ef9b14742651a77898","modified":1597996657054},{"_id":"source/_posts/minimum-distance-to-type-a-word-using-two-fingers.md","hash":"76b896d2ee6015bb9a7d0b8da41d119881ef0dd4","modified":1597996657055},{"_id":"source/_posts/minimum-number-of-increments-on-subarrays-to-form-a-target-array.md","hash":"12fb4605ac147bdbbc82bc1b4286037d73c6a158","modified":1597996657055},{"_id":"source/_posts/minimum-number-of-taps-to-open-to-water-a-garden.md","hash":"d65b16f2278098d30146f65cd46d15ba2b69a66e","modified":1597996657055},{"_id":"source/_posts/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.md","hash":"f0029e9084fee73772701682256a58b34fb6de27","modified":1597996657055},{"_id":"source/_posts/number-of-sub-arrays-with-odd-sum.md","hash":"44975964022718478ca934fb94ebe15467514abe","modified":1597996657056},{"_id":"source/_posts/number-of-ways-to-paint-n-3-grid.md","hash":"84f82909eb6ee1ec8f19f942d255cc82540e56db","modified":1597996657056},{"_id":"source/_posts/pizza-with-3n-slices.md","hash":"6e9abfb0b7cf707f9b4e82ce0cb83b6fb489c575","modified":1597996657056},{"_id":"source/_posts/remove-all-adjacent-duplicates-in-string.md","hash":"0b79898af5b311e9501aacf0f14968c0caad2013","modified":1597996657056},{"_id":"source/_posts/robot-bounded-in-circle.md","hash":"382fa740ed87dc077114d8da3f728f1ecc177bc3","modified":1597996657057},{"_id":"source/_posts/restore-the-array.md","hash":"e2c5a4828b772c1844e5a0a6b44b0d0be0659b1e","modified":1597996657057},{"_id":"source/_posts/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.md","hash":"fd3d5792a58a23e1325b8bd25fc4b0303578e57e","modified":1597996657057},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1597995455841},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1597995455841},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1597995455841},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1597995455841},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1597995455841},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1597995455846},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1597995455842},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1597995455841},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1597995455842},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1597995455842},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1597995455842},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1597995455842},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1597995455842},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1597995455842},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1597995455843},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1597995455842},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1597995455843},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1597995455843},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1597995455846},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1597995455846},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1597995455846},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1597995455846},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597995455846},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1597995455846},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597995455846},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1597995455847},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1597995455843},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1597995455843},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1597995455843},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1597995455843},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1597995455845},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1597995455845},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1597995455845},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1597995455845},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1597995455846},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1597995455846},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1597995455847},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1597995455849},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1597995455853},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1597995455853},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1597995455853},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1597995455853},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1597995455853},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1597995455855},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1597995455855},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1597995455855},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1597995455856},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1597995455844},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1597995455845},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1597995455845},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1597995455845},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1597995455845},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1597995455847},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1597995455847},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1597995455847},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1597995455847},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1597995455847},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1597995455848},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1597995455848},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1597995455848},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1597995455848},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1597995455848},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1597995455848},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1597995455848},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1597995455849},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1597995455849},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1597995455851},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1597995455854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1597995455855},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1597995455851},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1597995455850},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1597995455853}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Constrained Subsequence Sum's Solution","date":"2020-04-26T04:13:00.000Z","_content":"\n**Original Question**: [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597693/PythonC%2B%2B-DP-with-decreasing-deque)\n\n**Idea**<br>\nThis is a typical knapsack problem. we maintain an array `dp`, where `dp[i]` is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.\n\n\n\n\n- Base case: `dp[0] = nums[0]`\n<li>state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\n<ul>\n- NOTE that x can be a fresh start when all the previous dp are negative.\n\n\n\nThis algorithm is only \u0010`O(n * k)`, we need to improve it to `O(n)` because both `k` and `n` can be 10^5.\n\n\n\n\nThe Idea is straight-forward, we can maintain an non-increasing deque `decrease` that records the maximum value among `dp[i - k], dp[i-k+1], ..., dp[i - 1]`. When encountering a new value `x`, we only record it in `decrease` if `x > decrease[decrease.size - 1]`. Thus the first element in `decrease` will always be the largest value we want.\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = nums[:1]\n        decrease = collections.deque(dp)\n        for i, x in enumerate(nums[1:], 1):\n            if i > k and decrease[0] == dp[i - k - 1]:\n                decrease.popleft()\n            tmp = max(x, decrease[0] + x)\n            dp += tmp,\n            while decrease and decrease[-1] < tmp:\n                decrease.pop()\n            decrease += tmp,                \n        return max(dp)  \n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        vector<int> dp {nums[0]};\n        deque<int> decrease {nums[0]};\n        int res = nums[0];\n        \n        for (int i=1; i<nums.size(); i++) {\n            if (i > k && decrease[0] == dp[i - k - 1])\n                decrease.pop_front();\n            int tmp = max(nums[i], decrease[0] + nums[i]);\n            dp.push_back(tmp);\n            while (!decrease.empty() && decrease.back() < tmp)\n                decrease.pop_back();\n            decrease.push_back(tmp);\n            \n            res = max(res, tmp);\n        }\n        return res;\n        \n    }\n};\n\n```\n\n\n","source":"_posts/constrained-subsequence-sum.md","raw":"---\ntitle: Constrained Subsequence Sum's Solution\ndate: 2020-04-26 12:13:00\n---\n\n**Original Question**: [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597693/PythonC%2B%2B-DP-with-decreasing-deque)\n\n**Idea**<br>\nThis is a typical knapsack problem. we maintain an array `dp`, where `dp[i]` is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.\n\n\n\n\n- Base case: `dp[0] = nums[0]`\n<li>state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\n<ul>\n- NOTE that x can be a fresh start when all the previous dp are negative.\n\n\n\nThis algorithm is only \u0010`O(n * k)`, we need to improve it to `O(n)` because both `k` and `n` can be 10^5.\n\n\n\n\nThe Idea is straight-forward, we can maintain an non-increasing deque `decrease` that records the maximum value among `dp[i - k], dp[i-k+1], ..., dp[i - 1]`. When encountering a new value `x`, we only record it in `decrease` if `x > decrease[decrease.size - 1]`. Thus the first element in `decrease` will always be the largest value we want.\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\n        dp = nums[:1]\n        decrease = collections.deque(dp)\n        for i, x in enumerate(nums[1:], 1):\n            if i > k and decrease[0] == dp[i - k - 1]:\n                decrease.popleft()\n            tmp = max(x, decrease[0] + x)\n            dp += tmp,\n            while decrease and decrease[-1] < tmp:\n                decrease.pop()\n            decrease += tmp,                \n        return max(dp)  \n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        vector<int> dp {nums[0]};\n        deque<int> decrease {nums[0]};\n        int res = nums[0];\n        \n        for (int i=1; i<nums.size(); i++) {\n            if (i > k && decrease[0] == dp[i - k - 1])\n                decrease.pop_front();\n            int tmp = max(nums[i], decrease[0] + nums[i]);\n            dp.push_back(tmp);\n            while (!decrease.empty() && decrease.back() < tmp)\n                decrease.pop_back();\n            decrease.push_back(tmp);\n            \n            res = max(res, tmp);\n        }\n        return res;\n        \n    }\n};\n\n```\n\n\n","slug":"constrained-subsequence-sum","published":1,"updated":"2020-08-21T07:57:37.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykro00004ilu37fkb24c","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/constrained-subsequence-sum\">Constrained Subsequence Sum</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/constrained-subsequence-sum/discuss/597693/PythonC%2B%2B-DP-with-decreasing-deque\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical knapsack problem. we maintain an array <code>dp</code>, where <code>dp[i]</code> is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.</p>\n<ul>\n<li>Base case: <code>dp[0] = nums[0]</code><li>state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\n<ul></li>\n<li>NOTE that x can be a fresh start when all the previous dp are negative.</li>\n</ul>\n<p>This algorithm is only \u0010<code>O(n * k)</code>, we need to improve it to <code>O(n)</code> because both <code>k</code> and <code>n</code> can be 10^5.</p>\n<p>The Idea is straight-forward, we can maintain an non-increasing deque <code>decrease</code> that records the maximum value among <code>dp[i - k], dp[i-k+1], ..., dp[i - 1]</code>. When encountering a new value <code>x</code>, we only record it in <code>decrease</code> if <code>x &gt; decrease[decrease.size - 1]</code>. Thus the first element in <code>decrease</code> will always be the largest value we want.</p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def constrainedSubsetSum(self, nums: List[int], k: int) -&gt; int:</span><br><span class=\"line\">        dp &#x3D; nums[:1]</span><br><span class=\"line\">        decrease &#x3D; collections.deque(dp)</span><br><span class=\"line\">        for i, x in enumerate(nums[1:], 1):</span><br><span class=\"line\">            if i &gt; k and decrease[0] &#x3D;&#x3D; dp[i - k - 1]:</span><br><span class=\"line\">                decrease.popleft()</span><br><span class=\"line\">            tmp &#x3D; max(x, decrease[0] + x)</span><br><span class=\"line\">            dp +&#x3D; tmp,</span><br><span class=\"line\">            while decrease and decrease[-1] &lt; tmp:</span><br><span class=\"line\">                decrease.pop()</span><br><span class=\"line\">            decrease +&#x3D; tmp,                </span><br><span class=\"line\">        return max(dp)  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; dp &#123;nums[0]&#125;;</span><br><span class=\"line\">        deque&lt;int&gt; decrease &#123;nums[0]&#125;;</span><br><span class=\"line\">        int res &#x3D; nums[0];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i&#x3D;1; i&lt;nums.size(); i++) &#123;</span><br><span class=\"line\">            if (i &gt; k &amp;&amp; decrease[0] &#x3D;&#x3D; dp[i - k - 1])</span><br><span class=\"line\">                decrease.pop_front();</span><br><span class=\"line\">            int tmp &#x3D; max(nums[i], decrease[0] + nums[i]);</span><br><span class=\"line\">            dp.push_back(tmp);</span><br><span class=\"line\">            while (!decrease.empty() &amp;&amp; decrease.back() &lt; tmp)</span><br><span class=\"line\">                decrease.pop_back();</span><br><span class=\"line\">            decrease.push_back(tmp);</span><br><span class=\"line\">            </span><br><span class=\"line\">            res &#x3D; max(res, tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/constrained-subsequence-sum\">Constrained Subsequence Sum</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/constrained-subsequence-sum/discuss/597693/PythonC%2B%2B-DP-with-decreasing-deque\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical knapsack problem. we maintain an array <code>dp</code>, where <code>dp[i]</code> is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.</p>\n<ul>\n<li>Base case: <code>dp[0] = nums[0]</code><li>state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\n<ul></li>\n<li>NOTE that x can be a fresh start when all the previous dp are negative.</li>\n</ul>\n<p>This algorithm is only \u0010<code>O(n * k)</code>, we need to improve it to <code>O(n)</code> because both <code>k</code> and <code>n</code> can be 10^5.</p>\n<p>The Idea is straight-forward, we can maintain an non-increasing deque <code>decrease</code> that records the maximum value among <code>dp[i - k], dp[i-k+1], ..., dp[i - 1]</code>. When encountering a new value <code>x</code>, we only record it in <code>decrease</code> if <code>x &gt; decrease[decrease.size - 1]</code>. Thus the first element in <code>decrease</code> will always be the largest value we want.</p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def constrainedSubsetSum(self, nums: List[int], k: int) -&gt; int:</span><br><span class=\"line\">        dp &#x3D; nums[:1]</span><br><span class=\"line\">        decrease &#x3D; collections.deque(dp)</span><br><span class=\"line\">        for i, x in enumerate(nums[1:], 1):</span><br><span class=\"line\">            if i &gt; k and decrease[0] &#x3D;&#x3D; dp[i - k - 1]:</span><br><span class=\"line\">                decrease.popleft()</span><br><span class=\"line\">            tmp &#x3D; max(x, decrease[0] + x)</span><br><span class=\"line\">            dp +&#x3D; tmp,</span><br><span class=\"line\">            while decrease and decrease[-1] &lt; tmp:</span><br><span class=\"line\">                decrease.pop()</span><br><span class=\"line\">            decrease +&#x3D; tmp,                </span><br><span class=\"line\">        return max(dp)  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; dp &#123;nums[0]&#125;;</span><br><span class=\"line\">        deque&lt;int&gt; decrease &#123;nums[0]&#125;;</span><br><span class=\"line\">        int res &#x3D; nums[0];</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i&#x3D;1; i&lt;nums.size(); i++) &#123;</span><br><span class=\"line\">            if (i &gt; k &amp;&amp; decrease[0] &#x3D;&#x3D; dp[i - k - 1])</span><br><span class=\"line\">                decrease.pop_front();</span><br><span class=\"line\">            int tmp &#x3D; max(nums[i], decrease[0] + nums[i]);</span><br><span class=\"line\">            dp.push_back(tmp);</span><br><span class=\"line\">            while (!decrease.empty() &amp;&amp; decrease.back() &lt; tmp)</span><br><span class=\"line\">                decrease.pop_back();</span><br><span class=\"line\">            decrease.push_back(tmp);</span><br><span class=\"line\">            </span><br><span class=\"line\">            res &#x3D; max(res, tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Construct Target Array With Multiple Sums's Solution","date":"2020-02-18T04:33:00.000Z","_content":"\n**Original Question**: [Construct Target Array With Multiple Sums](https://leetcode.com/problems/construct-target-array-with-multiple-sums)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510338/Python-Replace-reversely)\n\nThe Idea is to reversely construct `[1, 1, ..., 1]` from `target`.\n\n\n\n\n**Complexity**<br>\nGiven the steps `K` to construct the target:<br>\nTime: O(KlogK)<br>\nSpace: O(N)\n\n\n\n\n**Updated Python 3**\n\n\n\n\n```\nimport heapq\nclass Solution:\n    def isPossible(self, A):\n        q = [-x for x in A]\n        heapq.heapify(q)\n        sm = sum(A)\n        while True:\n            high, rest = -q[0], sm + q[0]\n            if high == 1 or rest == 1: return True\n            original = high % rest\n            if rest >= high or not original: return False\n            sm -= high - original\n            heapq.heapreplace(q, -original)\n\n```\n\n\n\n**Orignal Python 3**\n\n\n\n\n```\nimport heapq\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        sm = sum(target)\n        q = [-x for x in target]\n        heapq.heapify(q)\n        while True:\n            high = -q[0]\n\t\t\toriginal = 2*high - sm\n            if original > high or original < 1: return False\n            sm -= high - original\n            heapq.heapreplace(q, -original)\n            if all(x == -1 for x in q):\n                return True\n\n```\n\n\n","source":"_posts/construct-target-array-with-multiple-sums.md","raw":"---\ntitle: Construct Target Array With Multiple Sums's Solution\ndate: 2020-02-18 12:33:00\n---\n\n**Original Question**: [Construct Target Array With Multiple Sums](https://leetcode.com/problems/construct-target-array-with-multiple-sums)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510338/Python-Replace-reversely)\n\nThe Idea is to reversely construct `[1, 1, ..., 1]` from `target`.\n\n\n\n\n**Complexity**<br>\nGiven the steps `K` to construct the target:<br>\nTime: O(KlogK)<br>\nSpace: O(N)\n\n\n\n\n**Updated Python 3**\n\n\n\n\n```\nimport heapq\nclass Solution:\n    def isPossible(self, A):\n        q = [-x for x in A]\n        heapq.heapify(q)\n        sm = sum(A)\n        while True:\n            high, rest = -q[0], sm + q[0]\n            if high == 1 or rest == 1: return True\n            original = high % rest\n            if rest >= high or not original: return False\n            sm -= high - original\n            heapq.heapreplace(q, -original)\n\n```\n\n\n\n**Orignal Python 3**\n\n\n\n\n```\nimport heapq\nclass Solution:\n    def isPossible(self, target: List[int]) -> bool:\n        sm = sum(target)\n        q = [-x for x in target]\n        heapq.heapify(q)\n        while True:\n            high = -q[0]\n\t\t\toriginal = 2*high - sm\n            if original > high or original < 1: return False\n            sm -= high - original\n            heapq.heapreplace(q, -original)\n            if all(x == -1 for x in q):\n                return True\n\n```\n\n\n","slug":"construct-target-array-with-multiple-sums","published":1,"updated":"2020-08-21T07:57:37.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrt00014ilu9slwadyh","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/construct-target-array-with-multiple-sums\">Construct Target Array With Multiple Sums</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510338/Python-Replace-reversely\">Solution</a></p>\n<p>The Idea is to reversely construct <code>[1, 1, ..., 1]</code> from <code>target</code>.</p>\n<p><strong>Complexity</strong><br><br>Given the steps <code>K</code> to construct the target:<br><br>Time: O(KlogK)<br><br>Space: O(N)</p>\n<p><strong>Updated Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import heapq</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isPossible(self, A):</span><br><span class=\"line\">        q &#x3D; [-x for x in A]</span><br><span class=\"line\">        heapq.heapify(q)</span><br><span class=\"line\">        sm &#x3D; sum(A)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            high, rest &#x3D; -q[0], sm + q[0]</span><br><span class=\"line\">            if high &#x3D;&#x3D; 1 or rest &#x3D;&#x3D; 1: return True</span><br><span class=\"line\">            original &#x3D; high % rest</span><br><span class=\"line\">            if rest &gt;&#x3D; high or not original: return False</span><br><span class=\"line\">            sm -&#x3D; high - original</span><br><span class=\"line\">            heapq.heapreplace(q, -original)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Orignal Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import heapq</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isPossible(self, target: List[int]) -&gt; bool:</span><br><span class=\"line\">        sm &#x3D; sum(target)</span><br><span class=\"line\">        q &#x3D; [-x for x in target]</span><br><span class=\"line\">        heapq.heapify(q)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            high &#x3D; -q[0]</span><br><span class=\"line\">            original &#x3D; 2*high - sm</span><br><span class=\"line\">            if original &gt; high or original &lt; 1: return False</span><br><span class=\"line\">            sm -&#x3D; high - original</span><br><span class=\"line\">            heapq.heapreplace(q, -original)</span><br><span class=\"line\">            if all(x &#x3D;&#x3D; -1 for x in q):</span><br><span class=\"line\">                return True</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/construct-target-array-with-multiple-sums\">Construct Target Array With Multiple Sums</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510338/Python-Replace-reversely\">Solution</a></p>\n<p>The Idea is to reversely construct <code>[1, 1, ..., 1]</code> from <code>target</code>.</p>\n<p><strong>Complexity</strong><br><br>Given the steps <code>K</code> to construct the target:<br><br>Time: O(KlogK)<br><br>Space: O(N)</p>\n<p><strong>Updated Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import heapq</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isPossible(self, A):</span><br><span class=\"line\">        q &#x3D; [-x for x in A]</span><br><span class=\"line\">        heapq.heapify(q)</span><br><span class=\"line\">        sm &#x3D; sum(A)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            high, rest &#x3D; -q[0], sm + q[0]</span><br><span class=\"line\">            if high &#x3D;&#x3D; 1 or rest &#x3D;&#x3D; 1: return True</span><br><span class=\"line\">            original &#x3D; high % rest</span><br><span class=\"line\">            if rest &gt;&#x3D; high or not original: return False</span><br><span class=\"line\">            sm -&#x3D; high - original</span><br><span class=\"line\">            heapq.heapreplace(q, -original)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Orignal Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import heapq</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isPossible(self, target: List[int]) -&gt; bool:</span><br><span class=\"line\">        sm &#x3D; sum(target)</span><br><span class=\"line\">        q &#x3D; [-x for x in target]</span><br><span class=\"line\">        heapq.heapify(q)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            high &#x3D; -q[0]</span><br><span class=\"line\">            original &#x3D; 2*high - sm</span><br><span class=\"line\">            if original &gt; high or original &lt; 1: return False</span><br><span class=\"line\">            sm -&#x3D; high - original</span><br><span class=\"line\">            heapq.heapreplace(q, -original)</span><br><span class=\"line\">            if all(x &#x3D;&#x3D; -1 for x in q):</span><br><span class=\"line\">                return True</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Count All Valid Pickup And Delivery Options's Solution","date":"2020-02-23T00:56:00.000Z","_content":"\n**Original Question**: [Count All Valid Pickup And Delivery Options](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/discuss/516933/C%2B%2BPython-1-line-Simple-permutation-with-explanation)\n\n**Idea**<br>\nDenote `pickup 1, pickup 2, pickup 3, ...` as `A, B, C, ...`<br>\nDenote `delivery 1, delivery 2, delivery 3, ...` as `a, b, c, ...`<br>\nWe need to ensure `a` is behind `A`, `b` is behind `B`, ...\n\n\n\n\nThis solution involves  2 stages.\n\n\n\n\n<li>Stage 1\n<ul>\n- We decide the order of all the pickups. It is trivial to tell there are `n!` possibilities\n\n- Given one possibility. Let's say the pickups are ordered  like this `A B C`\n<li>We can now insert the corresponding deliveries one by one.\n<ul>\n<li>We start with the last pickup we made, namely, insert `c`, and there is only 1 valid slot.\n<ul>\n- `A B C c`\n\n- `A B` **x** `C` **x** `c` **x** (where **x** denotes the location of valid slots for `b`)\n\n- `A` **x** `B` **x** `C` **x** `c` **x** `b` **x**, (where **x** denotes the location of valid slots for `a`)\n\n\n\n**Complexity**<br>\nTime: `O(n)`, can be improved to `O(1)` with memoization<br>\nSpace: `O(1)`\n\n\n\n\n**C++**\n\n\n\n\n```\nint countOrders(int n) {\n    long long res = 1, cap = 1000000007;\n    for (int i=1; i<n+1; ++i) res = res * i % cap;\n    for (int i=1; i<2*n; i+=2) res = res * i % cap;\n    return res;\n}\n\n```\n\n\n\n**Python 3, with explanations and meaningful variable names**\n\n\n\n\n```\nfrom functools import reduce\nfrom operator import mul\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        cap = 10**9 + 7\n        pickup_permutation = math.factorial(n) % cap\n        delivery_permutation = reduce(mul, range(1, 2*n, 2), 1) % cap\n        return pickup_permutation * delivery_permutation % cap\n\n```\n\n\n\n**Python 3, 1-line, mod along the way, O(1) space (12.8 MB)**\n\n\n\n\n```\nfrom functools import reduce\nclass Solution:\n    def countOrders(self, n: int) -> int:\n\t\t# remember to use generator instead of tuple for O(1) space complexity\n        return reduce(lambda x, y: x * y % (10**9+7), (v for x in range(1,n+1) for v in (x, 2*x-1)), 1)\n\n```\n\n\n\n**Python 3, 1-line, short, O(n) space**\n\n\n\n\n```\nfrom functools import reduce\nfrom operator import mul\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        return reduce(mul, (*range(1,n+1), *range(1,2*n,2)), 1) % (10**9+7)\n\n```\n\n\n","source":"_posts/count-all-valid-pickup-and-delivery-options.md","raw":"---\ntitle: Count All Valid Pickup And Delivery Options's Solution\ndate: 2020-02-23 08:56:00\n---\n\n**Original Question**: [Count All Valid Pickup And Delivery Options](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/discuss/516933/C%2B%2BPython-1-line-Simple-permutation-with-explanation)\n\n**Idea**<br>\nDenote `pickup 1, pickup 2, pickup 3, ...` as `A, B, C, ...`<br>\nDenote `delivery 1, delivery 2, delivery 3, ...` as `a, b, c, ...`<br>\nWe need to ensure `a` is behind `A`, `b` is behind `B`, ...\n\n\n\n\nThis solution involves  2 stages.\n\n\n\n\n<li>Stage 1\n<ul>\n- We decide the order of all the pickups. It is trivial to tell there are `n!` possibilities\n\n- Given one possibility. Let's say the pickups are ordered  like this `A B C`\n<li>We can now insert the corresponding deliveries one by one.\n<ul>\n<li>We start with the last pickup we made, namely, insert `c`, and there is only 1 valid slot.\n<ul>\n- `A B C c`\n\n- `A B` **x** `C` **x** `c` **x** (where **x** denotes the location of valid slots for `b`)\n\n- `A` **x** `B` **x** `C` **x** `c` **x** `b` **x**, (where **x** denotes the location of valid slots for `a`)\n\n\n\n**Complexity**<br>\nTime: `O(n)`, can be improved to `O(1)` with memoization<br>\nSpace: `O(1)`\n\n\n\n\n**C++**\n\n\n\n\n```\nint countOrders(int n) {\n    long long res = 1, cap = 1000000007;\n    for (int i=1; i<n+1; ++i) res = res * i % cap;\n    for (int i=1; i<2*n; i+=2) res = res * i % cap;\n    return res;\n}\n\n```\n\n\n\n**Python 3, with explanations and meaningful variable names**\n\n\n\n\n```\nfrom functools import reduce\nfrom operator import mul\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        cap = 10**9 + 7\n        pickup_permutation = math.factorial(n) % cap\n        delivery_permutation = reduce(mul, range(1, 2*n, 2), 1) % cap\n        return pickup_permutation * delivery_permutation % cap\n\n```\n\n\n\n**Python 3, 1-line, mod along the way, O(1) space (12.8 MB)**\n\n\n\n\n```\nfrom functools import reduce\nclass Solution:\n    def countOrders(self, n: int) -> int:\n\t\t# remember to use generator instead of tuple for O(1) space complexity\n        return reduce(lambda x, y: x * y % (10**9+7), (v for x in range(1,n+1) for v in (x, 2*x-1)), 1)\n\n```\n\n\n\n**Python 3, 1-line, short, O(n) space**\n\n\n\n\n```\nfrom functools import reduce\nfrom operator import mul\nclass Solution:\n    def countOrders(self, n: int) -> int:\n        return reduce(mul, (*range(1,n+1), *range(1,2*n,2)), 1) % (10**9+7)\n\n```\n\n\n","slug":"count-all-valid-pickup-and-delivery-options","published":1,"updated":"2020-08-21T07:57:37.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykru00024ilu9cetbfta","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options\">Count All Valid Pickup And Delivery Options</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/discuss/516933/C%2B%2BPython-1-line-Simple-permutation-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Denote <code>pickup 1, pickup 2, pickup 3, ...</code> as <code>A, B, C, ...</code><br><br>Denote <code>delivery 1, delivery 2, delivery 3, ...</code> as <code>a, b, c, ...</code><br><br>We need to ensure <code>a</code> is behind <code>A</code>, <code>b</code> is behind <code>B</code>, …</p>\n<p>This solution involves  2 stages.</p>\n<li>Stage 1\n<ul>\n- We decide the order of all the pickups. It is trivial to tell there are `n!` possibilities\n\n<ul>\n<li><p>Given one possibility. Let’s say the pickups are ordered  like this <code>A B C</code></p>\n<li>We can now insert the corresponding deliveries one by one.\n<ul>\n<li>We start with the last pickup we made, namely, insert `c`, and there is only 1 valid slot.\n<ul></li>\n<li><p><code>A B C c</code></p>\n</li>\n<li><p><code>A B</code> <strong>x</strong> <code>C</code> <strong>x</strong> <code>c</code> <strong>x</strong> (where <strong>x</strong> denotes the location of valid slots for <code>b</code>)</p>\n</li>\n<li><p><code>A</code> <strong>x</strong> <code>B</code> <strong>x</strong> <code>C</code> <strong>x</strong> <code>c</code> <strong>x</strong> <code>b</code> <strong>x</strong>, (where <strong>x</strong> denotes the location of valid slots for <code>a</code>)</p>\n</li>\n</ul>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code>, can be improved to <code>O(1)</code> with memoization<br><br>Space: <code>O(1)</code></p>\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int countOrders(int n) &#123;</span><br><span class=\"line\">    long long res &#x3D; 1, cap &#x3D; 1000000007;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;n+1; ++i) res &#x3D; res * i % cap;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;2*n; i+&#x3D;2) res &#x3D; res * i % cap;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, with explanations and meaningful variable names</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">from operator import mul</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        cap &#x3D; 10**9 + 7</span><br><span class=\"line\">        pickup_permutation &#x3D; math.factorial(n) % cap</span><br><span class=\"line\">        delivery_permutation &#x3D; reduce(mul, range(1, 2*n, 2), 1) % cap</span><br><span class=\"line\">        return pickup_permutation * delivery_permutation % cap</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, 1-line, mod along the way, O(1) space (12.8 MB)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        # remember to use generator instead of tuple for O(1) space complexity</span><br><span class=\"line\">        return reduce(lambda x, y: x * y % (10**9+7), (v for x in range(1,n+1) for v in (x, 2*x-1)), 1)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, 1-line, short, O(n) space</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">from operator import mul</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        return reduce(mul, (*range(1,n+1), *range(1,2*n,2)), 1) % (10**9+7)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options\">Count All Valid Pickup And Delivery Options</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/discuss/516933/C%2B%2BPython-1-line-Simple-permutation-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Denote <code>pickup 1, pickup 2, pickup 3, ...</code> as <code>A, B, C, ...</code><br><br>Denote <code>delivery 1, delivery 2, delivery 3, ...</code> as <code>a, b, c, ...</code><br><br>We need to ensure <code>a</code> is behind <code>A</code>, <code>b</code> is behind <code>B</code>, …</p>\n<p>This solution involves  2 stages.</p>\n<li>Stage 1\n<ul>\n- We decide the order of all the pickups. It is trivial to tell there are `n!` possibilities\n\n<ul>\n<li><p>Given one possibility. Let’s say the pickups are ordered  like this <code>A B C</code></p>\n<li>We can now insert the corresponding deliveries one by one.\n<ul>\n<li>We start with the last pickup we made, namely, insert `c`, and there is only 1 valid slot.\n<ul></li>\n<li><p><code>A B C c</code></p>\n</li>\n<li><p><code>A B</code> <strong>x</strong> <code>C</code> <strong>x</strong> <code>c</code> <strong>x</strong> (where <strong>x</strong> denotes the location of valid slots for <code>b</code>)</p>\n</li>\n<li><p><code>A</code> <strong>x</strong> <code>B</code> <strong>x</strong> <code>C</code> <strong>x</strong> <code>c</code> <strong>x</strong> <code>b</code> <strong>x</strong>, (where <strong>x</strong> denotes the location of valid slots for <code>a</code>)</p>\n</li>\n</ul>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code>, can be improved to <code>O(1)</code> with memoization<br><br>Space: <code>O(1)</code></p>\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int countOrders(int n) &#123;</span><br><span class=\"line\">    long long res &#x3D; 1, cap &#x3D; 1000000007;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;n+1; ++i) res &#x3D; res * i % cap;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;2*n; i+&#x3D;2) res &#x3D; res * i % cap;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, with explanations and meaningful variable names</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">from operator import mul</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        cap &#x3D; 10**9 + 7</span><br><span class=\"line\">        pickup_permutation &#x3D; math.factorial(n) % cap</span><br><span class=\"line\">        delivery_permutation &#x3D; reduce(mul, range(1, 2*n, 2), 1) % cap</span><br><span class=\"line\">        return pickup_permutation * delivery_permutation % cap</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, 1-line, mod along the way, O(1) space (12.8 MB)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        # remember to use generator instead of tuple for O(1) space complexity</span><br><span class=\"line\">        return reduce(lambda x, y: x * y % (10**9+7), (v for x in range(1,n+1) for v in (x, 2*x-1)), 1)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, 1-line, short, O(n) space</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">from operator import mul</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def countOrders(self, n: int) -&gt; int:</span><br><span class=\"line\">        return reduce(mul, (*range(1,n+1), *range(1,2*n,2)), 1) % (10**9+7)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Find A Value Of A Mysterious Function Closest To Target's Solution","date":"2020-07-25T02:47:00.000Z","_content":"\n**Original Question**: [Find A Value Of A Mysterious Function Closest To Target](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743142/on2-simple-brute-force-solution)\n\n**Idea**<br>\nThe idea is that & operation will only makes a number smaller. For most cases, `arr[i]` loses at least 1 bit, and let `arr[i]` drop to zero in O(log(arr[i])) steps.\n\n\n\n\n**Complexity**<br>\nTime: O(n^2), but perform very much like O(nlogK) for the above reasons, where K = max(arr).<br>\nSpace: O(1)\n\n\n\n\nPlease leave an upvote if it helps, they mean a lot to me.\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        res = math.inf\n        \n        for i, x in enumerate(arr):\n            curr = x\n            diff = abs(target - curr)\n            for j in range(i + 1, len(arr)):\n                x_ = arr[j]\n                curr &= x_\n                if abs(curr - target) >= diff:                    \n                    break\n                diff = abs(curr - target)\n            res = min(res, diff)\n                \n        return res\n                \n\n```\n\n\n","source":"_posts/find-a-value-of-a-mysterious-function-closest-to-target.md","raw":"---\ntitle: Find A Value Of A Mysterious Function Closest To Target's Solution\ndate: 2020-07-25 10:47:00\n---\n\n**Original Question**: [Find A Value Of A Mysterious Function Closest To Target](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743142/on2-simple-brute-force-solution)\n\n**Idea**<br>\nThe idea is that & operation will only makes a number smaller. For most cases, `arr[i]` loses at least 1 bit, and let `arr[i]` drop to zero in O(log(arr[i])) steps.\n\n\n\n\n**Complexity**<br>\nTime: O(n^2), but perform very much like O(nlogK) for the above reasons, where K = max(arr).<br>\nSpace: O(1)\n\n\n\n\nPlease leave an upvote if it helps, they mean a lot to me.\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        res = math.inf\n        \n        for i, x in enumerate(arr):\n            curr = x\n            diff = abs(target - curr)\n            for j in range(i + 1, len(arr)):\n                x_ = arr[j]\n                curr &= x_\n                if abs(curr - target) >= diff:                    \n                    break\n                diff = abs(curr - target)\n            res = min(res, diff)\n                \n        return res\n                \n\n```\n\n\n","slug":"find-a-value-of-a-mysterious-function-closest-to-target","published":1,"updated":"2020-08-21T07:57:37.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrv00034ilugkql7qrf","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target\">Find A Value Of A Mysterious Function Closest To Target</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743142/on2-simple-brute-force-solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The idea is that &amp; operation will only makes a number smaller. For most cases, <code>arr[i]</code> loses at least 1 bit, and let <code>arr[i]</code> drop to zero in O(log(arr[i])) steps.</p>\n<p><strong>Complexity</strong><br><br>Time: O(n^2), but perform very much like O(nlogK) for the above reasons, where K = max(arr).<br><br>Space: O(1)</p>\n<p>Please leave an upvote if it helps, they mean a lot to me.</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def closestToTarget(self, arr: List[int], target: int) -&gt; int:</span><br><span class=\"line\">        res &#x3D; math.inf</span><br><span class=\"line\">        </span><br><span class=\"line\">        for i, x in enumerate(arr):</span><br><span class=\"line\">            curr &#x3D; x</span><br><span class=\"line\">            diff &#x3D; abs(target - curr)</span><br><span class=\"line\">            for j in range(i + 1, len(arr)):</span><br><span class=\"line\">                x_ &#x3D; arr[j]</span><br><span class=\"line\">                curr &amp;&#x3D; x_</span><br><span class=\"line\">                if abs(curr - target) &gt;&#x3D; diff:                    </span><br><span class=\"line\">                    break</span><br><span class=\"line\">                diff &#x3D; abs(curr - target)</span><br><span class=\"line\">            res &#x3D; min(res, diff)</span><br><span class=\"line\">                </span><br><span class=\"line\">        return res</span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target\">Find A Value Of A Mysterious Function Closest To Target</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743142/on2-simple-brute-force-solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The idea is that &amp; operation will only makes a number smaller. For most cases, <code>arr[i]</code> loses at least 1 bit, and let <code>arr[i]</code> drop to zero in O(log(arr[i])) steps.</p>\n<p><strong>Complexity</strong><br><br>Time: O(n^2), but perform very much like O(nlogK) for the above reasons, where K = max(arr).<br><br>Space: O(1)</p>\n<p>Please leave an upvote if it helps, they mean a lot to me.</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def closestToTarget(self, arr: List[int], target: int) -&gt; int:</span><br><span class=\"line\">        res &#x3D; math.inf</span><br><span class=\"line\">        </span><br><span class=\"line\">        for i, x in enumerate(arr):</span><br><span class=\"line\">            curr &#x3D; x</span><br><span class=\"line\">            diff &#x3D; abs(target - curr)</span><br><span class=\"line\">            for j in range(i + 1, len(arr)):</span><br><span class=\"line\">                x_ &#x3D; arr[j]</span><br><span class=\"line\">                curr &amp;&#x3D; x_</span><br><span class=\"line\">                if abs(curr - target) &gt;&#x3D; diff:                    </span><br><span class=\"line\">                    break</span><br><span class=\"line\">                diff &#x3D; abs(curr - target)</span><br><span class=\"line\">            res &#x3D; min(res, diff)</span><br><span class=\"line\">                </span><br><span class=\"line\">        return res</span><br><span class=\"line\">                </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Frog Position After T Seconds's Solution","date":"2020-03-08T04:21:00.000Z","_content":"\n**Original Question**: [Frog Position After T Seconds](https://leetcode.com/problems/frog-position-after-t-seconds)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/frog-position-after-t-seconds/discuss/532475/python-easy-dfsbfs-with-explanation)\n\n**Idea**<br>\nFirst we build an adjacency list using `edges`.<br>\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\n\n\n\n\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\n1. Use set to record all the visited nodes along the way **(method 2)**\n\n\n\n**Complexity**<br>\nTime: `O(N)`<br>\nSpace: `O(N)`\n\n\n\n\n**Python 3, DFS with recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res\n\n```\n\n\n\n**Python 3, BFS without recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.popleft()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n\n```\n\n\n\n**Python 3, DFS without recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.pop()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n\n```\n\n\n\n**Python 3, DFS on tree without recursion, method 1**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n                    \n        dp = collections.deque([1])\n        while dp:\n            leaf = dp.popleft()\n            for n_ in nei[leaf]:\n                nei[n_].remove(leaf)\n                dp += n_,\n                \n        dp = [(1, 1, 0)]\n        while dp:\n            leaf, p, curr = dp.pop()\n            if curr >= t:\n                if leaf == target: return p\n                continue\n            for n in nei[leaf] or [leaf]:\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\n        return 0.0\n\n```\n\n\n","source":"_posts/frog-position-after-t-seconds.md","raw":"---\ntitle: Frog Position After T Seconds's Solution\ndate: 2020-03-08 12:21:00\n---\n\n**Original Question**: [Frog Position After T Seconds](https://leetcode.com/problems/frog-position-after-t-seconds)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/frog-position-after-t-seconds/discuss/532475/python-easy-dfsbfs-with-explanation)\n\n**Idea**<br>\nFirst we build an adjacency list using `edges`.<br>\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\n\n\n\n\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\n1. Use set to record all the visited nodes along the way **(method 2)**\n\n\n\n**Complexity**<br>\nTime: `O(N)`<br>\nSpace: `O(N)`\n\n\n\n\n**Python 3, DFS with recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res\n\n```\n\n\n\n**Python 3, BFS without recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.popleft()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n\n```\n\n\n\n**Python 3, DFS without recursion, method 2**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\n        visited = set()\n        \n        while dp:\n            leaf, p, curr = dp.pop()\n            visited.add(leaf)\n            \n            if curr >= t:\n                if leaf == target: return p\n                continue\n            \n            neighbors = nei[leaf] - visited\n            for n in neighbors or [leaf]:\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\n        return 0.\n\n```\n\n\n\n**Python 3, DFS on tree without recursion, method 1**\n\n\n\n\n```\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n                    \n        dp = collections.deque([1])\n        while dp:\n            leaf = dp.popleft()\n            for n_ in nei[leaf]:\n                nei[n_].remove(leaf)\n                dp += n_,\n                \n        dp = [(1, 1, 0)]\n        while dp:\n            leaf, p, curr = dp.pop()\n            if curr >= t:\n                if leaf == target: return p\n                continue\n            for n in nei[leaf] or [leaf]:\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\n        return 0.0\n\n```\n\n\n","slug":"frog-position-after-t-seconds","published":1,"updated":"2020-08-21T07:57:37.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrw00044ilubn7812wk","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/frog-position-after-t-seconds\">Frog Position After T Seconds</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/frog-position-after-t-seconds/discuss/532475/python-easy-dfsbfs-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>First we build an adjacency list using <code>edges</code>.<br><br>We then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.</p>\n<ol>\n<li>Construct a undirected graph and transform it into a directed tree first <strong>(method 1)</strong></li>\n<li>Use set to record all the visited nodes along the way <strong>(method 2)</strong></li>\n</ol>\n<p><strong>Complexity</strong><br><br>Time: <code>O(N)</code><br><br>Space: <code>O(N)</code></p>\n<p><strong>Python 3, DFS with recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        visited, res &#x3D; set(), 0.</span><br><span class=\"line\">        def dfs(leaf_id, p, time):</span><br><span class=\"line\">            nonlocal res</span><br><span class=\"line\">            if time &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf_id &#x3D;&#x3D; target: res &#x3D; p</span><br><span class=\"line\">                return</span><br><span class=\"line\">            visited.add(leaf_id)</span><br><span class=\"line\">            neighbors &#x3D; nei[leaf_id] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf_id]:</span><br><span class=\"line\">                dfs(n, p &#x2F; (len(neighbors) or 1), time + 1)</span><br><span class=\"line\">        dfs(1, 1, 0)</span><br><span class=\"line\">        return res</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, BFS without recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        dp &#x3D; collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp</span><br><span class=\"line\">        visited &#x3D; set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.popleft()</span><br><span class=\"line\">            visited.add(leaf)</span><br><span class=\"line\">            </span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            </span><br><span class=\"line\">            neighbors &#x3D; nei[leaf] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(neighbors) or 1), curr + 1),</span><br><span class=\"line\">        return 0.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, DFS without recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        dp &#x3D; [(1, 1, 0)] # state: leaf_id, possibility, timestamp</span><br><span class=\"line\">        visited &#x3D; set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.pop()</span><br><span class=\"line\">            visited.add(leaf)</span><br><span class=\"line\">            </span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            </span><br><span class=\"line\">            neighbors &#x3D; nei[leaf] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(neighbors) or 1), curr + 1),</span><br><span class=\"line\">        return 0.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, DFS on tree without recursion, method 1</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        dp &#x3D; collections.deque([1])</span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf &#x3D; dp.popleft()</span><br><span class=\"line\">            for n_ in nei[leaf]:</span><br><span class=\"line\">                nei[n_].remove(leaf)</span><br><span class=\"line\">                dp +&#x3D; n_,</span><br><span class=\"line\">                </span><br><span class=\"line\">        dp &#x3D; [(1, 1, 0)]</span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.pop()</span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            for n in nei[leaf] or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(nei[leaf]) or 1), curr+1),</span><br><span class=\"line\">        return 0.0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/frog-position-after-t-seconds\">Frog Position After T Seconds</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/frog-position-after-t-seconds/discuss/532475/python-easy-dfsbfs-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>First we build an adjacency list using <code>edges</code>.<br><br>We then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.</p>\n<ol>\n<li>Construct a undirected graph and transform it into a directed tree first <strong>(method 1)</strong></li>\n<li>Use set to record all the visited nodes along the way <strong>(method 2)</strong></li>\n</ol>\n<p><strong>Complexity</strong><br><br>Time: <code>O(N)</code><br><br>Space: <code>O(N)</code></p>\n<p><strong>Python 3, DFS with recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        visited, res &#x3D; set(), 0.</span><br><span class=\"line\">        def dfs(leaf_id, p, time):</span><br><span class=\"line\">            nonlocal res</span><br><span class=\"line\">            if time &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf_id &#x3D;&#x3D; target: res &#x3D; p</span><br><span class=\"line\">                return</span><br><span class=\"line\">            visited.add(leaf_id)</span><br><span class=\"line\">            neighbors &#x3D; nei[leaf_id] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf_id]:</span><br><span class=\"line\">                dfs(n, p &#x2F; (len(neighbors) or 1), time + 1)</span><br><span class=\"line\">        dfs(1, 1, 0)</span><br><span class=\"line\">        return res</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, BFS without recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        dp &#x3D; collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp</span><br><span class=\"line\">        visited &#x3D; set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.popleft()</span><br><span class=\"line\">            visited.add(leaf)</span><br><span class=\"line\">            </span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            </span><br><span class=\"line\">            neighbors &#x3D; nei[leaf] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(neighbors) or 1), curr + 1),</span><br><span class=\"line\">        return 0.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, DFS without recursion, method 2</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">            </span><br><span class=\"line\">        dp &#x3D; [(1, 1, 0)] # state: leaf_id, possibility, timestamp</span><br><span class=\"line\">        visited &#x3D; set()</span><br><span class=\"line\">        </span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.pop()</span><br><span class=\"line\">            visited.add(leaf)</span><br><span class=\"line\">            </span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            </span><br><span class=\"line\">            neighbors &#x3D; nei[leaf] - visited</span><br><span class=\"line\">            for n in neighbors or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(neighbors) or 1), curr + 1),</span><br><span class=\"line\">        return 0.</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, DFS on tree without recursion, method 1</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -&gt; float:</span><br><span class=\"line\">        nei &#x3D; collections.defaultdict(set)</span><br><span class=\"line\">        for a, b in edges:</span><br><span class=\"line\">            nei[a].add(b)</span><br><span class=\"line\">            nei[b].add(a)</span><br><span class=\"line\">                    </span><br><span class=\"line\">        dp &#x3D; collections.deque([1])</span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf &#x3D; dp.popleft()</span><br><span class=\"line\">            for n_ in nei[leaf]:</span><br><span class=\"line\">                nei[n_].remove(leaf)</span><br><span class=\"line\">                dp +&#x3D; n_,</span><br><span class=\"line\">                </span><br><span class=\"line\">        dp &#x3D; [(1, 1, 0)]</span><br><span class=\"line\">        while dp:</span><br><span class=\"line\">            leaf, p, curr &#x3D; dp.pop()</span><br><span class=\"line\">            if curr &gt;&#x3D; t:</span><br><span class=\"line\">                if leaf &#x3D;&#x3D; target: return p</span><br><span class=\"line\">                continue</span><br><span class=\"line\">            for n in nei[leaf] or [leaf]:</span><br><span class=\"line\">                dp +&#x3D; (n, p &#x2F; (len(nei[leaf]) or 1), curr+1),</span><br><span class=\"line\">        return 0.0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Largest Divisible Subset's Solution","date":"2020-06-13T09:09:00.000Z","_content":"\n**Original Question**: [Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/largest-divisible-subset/discuss/684795/python-onlogn-nsqrtv-beats-100)\n\n**Idea**<br>\nFirst, sort the array `O(nlogn)`.<br>\nWe maintain a dictionary `d` where `d[v]` records the longest subsequence **ending with v**.<br>\nWhen encountering a new value `v`, `v` can only be appended to those subsequence ending with `v`'s factors. Thus, we only needs to iterate through `v`'s factors, which is `O(sqrt(V))`\n\n\n\n\n**Complexity**\n\n\n\n\n- time: `O(nlogn + n*sqrt(V)), where V is the size of number`\n- space: `O(VN)`\n\n\n\n**Python3**\n\n\n\n\n```\n# factors, O(nlogn + nlogV), V is the size of num in nums\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        def factors(n):\n            yield 1\n            for i in range(2, int(math.sqrt(n)) + 1):\n                if not n % i:\n                    yield i\n                    if i * i != n:\n                        yield n // i\n                        \n        nums.sort()                        \n        d = {}            \n        for n in nums:\n            for f in factors(n):\n                tmp = d.get(f, []) + [n]\n                d[n] = tmp if len(d.get(n, [])) < len(tmp) else d.get(n, [])\n        return nums and max(d.values(), key=len)\n        # AC: 100 ms, beats 100.00%, 13.9 MB\n\n```\n\n\n","source":"_posts/largest-divisible-subset.md","raw":"---\ntitle: Largest Divisible Subset's Solution\ndate: 2020-06-13 17:09:00\n---\n\n**Original Question**: [Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/largest-divisible-subset/discuss/684795/python-onlogn-nsqrtv-beats-100)\n\n**Idea**<br>\nFirst, sort the array `O(nlogn)`.<br>\nWe maintain a dictionary `d` where `d[v]` records the longest subsequence **ending with v**.<br>\nWhen encountering a new value `v`, `v` can only be appended to those subsequence ending with `v`'s factors. Thus, we only needs to iterate through `v`'s factors, which is `O(sqrt(V))`\n\n\n\n\n**Complexity**\n\n\n\n\n- time: `O(nlogn + n*sqrt(V)), where V is the size of number`\n- space: `O(VN)`\n\n\n\n**Python3**\n\n\n\n\n```\n# factors, O(nlogn + nlogV), V is the size of num in nums\nclass Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\n        def factors(n):\n            yield 1\n            for i in range(2, int(math.sqrt(n)) + 1):\n                if not n % i:\n                    yield i\n                    if i * i != n:\n                        yield n // i\n                        \n        nums.sort()                        \n        d = {}            \n        for n in nums:\n            for f in factors(n):\n                tmp = d.get(f, []) + [n]\n                d[n] = tmp if len(d.get(n, [])) < len(tmp) else d.get(n, [])\n        return nums and max(d.values(), key=len)\n        # AC: 100 ms, beats 100.00%, 13.9 MB\n\n```\n\n\n","slug":"largest-divisible-subset","published":1,"updated":"2020-08-21T07:57:37.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrw00054ilubg7gax7w","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/largest-divisible-subset\">Largest Divisible Subset</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/largest-divisible-subset/discuss/684795/python-onlogn-nsqrtv-beats-100\">Solution</a></p>\n<p><strong>Idea</strong><br><br>First, sort the array <code>O(nlogn)</code>.<br><br>We maintain a dictionary <code>d</code> where <code>d[v]</code> records the longest subsequence <strong>ending with v</strong>.<br><br>When encountering a new value <code>v</code>, <code>v</code> can only be appended to those subsequence ending with <code>v</code>‘s factors. Thus, we only needs to iterate through <code>v</code>‘s factors, which is <code>O(sqrt(V))</code></p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>time: <code>O(nlogn + n*sqrt(V)), where V is the size of number</code></li>\n<li>space: <code>O(VN)</code></li>\n</ul>\n<p><strong>Python3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># factors, O(nlogn + nlogV), V is the size of num in nums</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:</span><br><span class=\"line\">        def factors(n):</span><br><span class=\"line\">            yield 1</span><br><span class=\"line\">            for i in range(2, int(math.sqrt(n)) + 1):</span><br><span class=\"line\">                if not n % i:</span><br><span class=\"line\">                    yield i</span><br><span class=\"line\">                    if i * i !&#x3D; n:</span><br><span class=\"line\">                        yield n &#x2F;&#x2F; i</span><br><span class=\"line\">                        </span><br><span class=\"line\">        nums.sort()                        </span><br><span class=\"line\">        d &#x3D; &#123;&#125;            </span><br><span class=\"line\">        for n in nums:</span><br><span class=\"line\">            for f in factors(n):</span><br><span class=\"line\">                tmp &#x3D; d.get(f, []) + [n]</span><br><span class=\"line\">                d[n] &#x3D; tmp if len(d.get(n, [])) &lt; len(tmp) else d.get(n, [])</span><br><span class=\"line\">        return nums and max(d.values(), key&#x3D;len)</span><br><span class=\"line\">        # AC: 100 ms, beats 100.00%, 13.9 MB</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/largest-divisible-subset\">Largest Divisible Subset</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/largest-divisible-subset/discuss/684795/python-onlogn-nsqrtv-beats-100\">Solution</a></p>\n<p><strong>Idea</strong><br><br>First, sort the array <code>O(nlogn)</code>.<br><br>We maintain a dictionary <code>d</code> where <code>d[v]</code> records the longest subsequence <strong>ending with v</strong>.<br><br>When encountering a new value <code>v</code>, <code>v</code> can only be appended to those subsequence ending with <code>v</code>‘s factors. Thus, we only needs to iterate through <code>v</code>‘s factors, which is <code>O(sqrt(V))</code></p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>time: <code>O(nlogn + n*sqrt(V)), where V is the size of number</code></li>\n<li>space: <code>O(VN)</code></li>\n</ul>\n<p><strong>Python3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># factors, O(nlogn + nlogV), V is the size of num in nums</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:</span><br><span class=\"line\">        def factors(n):</span><br><span class=\"line\">            yield 1</span><br><span class=\"line\">            for i in range(2, int(math.sqrt(n)) + 1):</span><br><span class=\"line\">                if not n % i:</span><br><span class=\"line\">                    yield i</span><br><span class=\"line\">                    if i * i !&#x3D; n:</span><br><span class=\"line\">                        yield n &#x2F;&#x2F; i</span><br><span class=\"line\">                        </span><br><span class=\"line\">        nums.sort()                        </span><br><span class=\"line\">        d &#x3D; &#123;&#125;            </span><br><span class=\"line\">        for n in nums:</span><br><span class=\"line\">            for f in factors(n):</span><br><span class=\"line\">                tmp &#x3D; d.get(f, []) + [n]</span><br><span class=\"line\">                d[n] &#x3D; tmp if len(d.get(n, [])) &lt; len(tmp) else d.get(n, [])</span><br><span class=\"line\">        return nums and max(d.values(), key&#x3D;len)</span><br><span class=\"line\">        # AC: 100 ms, beats 100.00%, 13.9 MB</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-08-21T07:32:37.468Z","updated":"2020-08-21T07:32:37.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrx00064ilucbh1eram","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Longest Happy Prefix's Solution","date":"2020-03-22T05:13:00.000Z","_content":"\n**Original Question**: [Longest Happy Prefix](https://leetcode.com/problems/longest-happy-prefix)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/longest-happy-prefix/discuss/547192/Python-O(n)-time-KMP-Search-with-explanation)\n\n**Idea**<br>\nThis is a typical string-matching problem. More details [here](http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm).<br>\nAll we need to do is to find the first occurrence of pattern `s[0...n-2]` in `s[1...n-1]` in O(n) time.\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python 3**\n\n\n\n\n```\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        if len(s) == 1: return ''\n        \n        def KMPSearch(pat, txt): \n            M, N = len(pat), len(txt) \n            lps = failure(pat)\n\n            i = 0 # index for txt[] \n            j = 0 # index for pat[] \n            while i < N: \n                if pat[j] == txt[i]: \n                    i += 1\n                    j += 1\n                elif i < N and pat[j] != txt[i]: \n                    if j != 0: \n                        j = lps[j-1] \n                    else: \n                        i += 1\n                if i >= N:                        \n                    return i - j \n\n        def failure(pat): \n            res = [0]\n            i, target = 1, 0\n            while i < len(pat): \n                if pat[i]== pat[target]: \n                    target += 1\n                    res += target,\n                    i += 1\n                elif target: \n                    target = res[target-1] \n                else: \n                    res += 0,\n                    i += 1\n            return res                        \n                        \n        l = len(s) - 1 - KMPSearch(s[:-1], s[1:])\n        return s[:l]\n\n```\n\n\n","source":"_posts/longest-happy-prefix.md","raw":"---\ntitle: Longest Happy Prefix's Solution\ndate: 2020-03-22 13:13:00\n---\n\n**Original Question**: [Longest Happy Prefix](https://leetcode.com/problems/longest-happy-prefix)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/longest-happy-prefix/discuss/547192/Python-O(n)-time-KMP-Search-with-explanation)\n\n**Idea**<br>\nThis is a typical string-matching problem. More details [here](http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm).<br>\nAll we need to do is to find the first occurrence of pattern `s[0...n-2]` in `s[1...n-1]` in O(n) time.\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python 3**\n\n\n\n\n```\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        if len(s) == 1: return ''\n        \n        def KMPSearch(pat, txt): \n            M, N = len(pat), len(txt) \n            lps = failure(pat)\n\n            i = 0 # index for txt[] \n            j = 0 # index for pat[] \n            while i < N: \n                if pat[j] == txt[i]: \n                    i += 1\n                    j += 1\n                elif i < N and pat[j] != txt[i]: \n                    if j != 0: \n                        j = lps[j-1] \n                    else: \n                        i += 1\n                if i >= N:                        \n                    return i - j \n\n        def failure(pat): \n            res = [0]\n            i, target = 1, 0\n            while i < len(pat): \n                if pat[i]== pat[target]: \n                    target += 1\n                    res += target,\n                    i += 1\n                elif target: \n                    target = res[target-1] \n                else: \n                    res += 0,\n                    i += 1\n            return res                        \n                        \n        l = len(s) - 1 - KMPSearch(s[:-1], s[1:])\n        return s[:l]\n\n```\n\n\n","slug":"longest-happy-prefix","published":1,"updated":"2020-08-21T07:57:37.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykry00074ilu9qsp5iro","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/longest-happy-prefix\">Longest Happy Prefix</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/longest-happy-prefix/discuss/547192/Python-O(n)-time-KMP-Search-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical string-matching problem. More details <a href=\"http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\">here</a>.<br><br>All we need to do is to find the first occurrence of pattern <code>s[0...n-2]</code> in <code>s[1...n-1]</code> in O(n) time.</p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def longestPrefix(self, s: str) -&gt; str:</span><br><span class=\"line\">        if len(s) &#x3D;&#x3D; 1: return &#39;&#39;</span><br><span class=\"line\">        </span><br><span class=\"line\">        def KMPSearch(pat, txt): </span><br><span class=\"line\">            M, N &#x3D; len(pat), len(txt) </span><br><span class=\"line\">            lps &#x3D; failure(pat)</span><br><span class=\"line\"></span><br><span class=\"line\">            i &#x3D; 0 # index for txt[] </span><br><span class=\"line\">            j &#x3D; 0 # index for pat[] </span><br><span class=\"line\">            while i &lt; N: </span><br><span class=\"line\">                if pat[j] &#x3D;&#x3D; txt[i]: </span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">                    j +&#x3D; 1</span><br><span class=\"line\">                elif i &lt; N and pat[j] !&#x3D; txt[i]: </span><br><span class=\"line\">                    if j !&#x3D; 0: </span><br><span class=\"line\">                        j &#x3D; lps[j-1] </span><br><span class=\"line\">                    else: </span><br><span class=\"line\">                        i +&#x3D; 1</span><br><span class=\"line\">                if i &gt;&#x3D; N:                        </span><br><span class=\"line\">                    return i - j </span><br><span class=\"line\"></span><br><span class=\"line\">        def failure(pat): </span><br><span class=\"line\">            res &#x3D; [0]</span><br><span class=\"line\">            i, target &#x3D; 1, 0</span><br><span class=\"line\">            while i &lt; len(pat): </span><br><span class=\"line\">                if pat[i]&#x3D;&#x3D; pat[target]: </span><br><span class=\"line\">                    target +&#x3D; 1</span><br><span class=\"line\">                    res +&#x3D; target,</span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">                elif target: </span><br><span class=\"line\">                    target &#x3D; res[target-1] </span><br><span class=\"line\">                else: </span><br><span class=\"line\">                    res +&#x3D; 0,</span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">            return res                        </span><br><span class=\"line\">                        </span><br><span class=\"line\">        l &#x3D; len(s) - 1 - KMPSearch(s[:-1], s[1:])</span><br><span class=\"line\">        return s[:l]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/longest-happy-prefix\">Longest Happy Prefix</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/longest-happy-prefix/discuss/547192/Python-O(n)-time-KMP-Search-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical string-matching problem. More details <a href=\"http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\">here</a>.<br><br>All we need to do is to find the first occurrence of pattern <code>s[0...n-2]</code> in <code>s[1...n-1]</code> in O(n) time.</p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def longestPrefix(self, s: str) -&gt; str:</span><br><span class=\"line\">        if len(s) &#x3D;&#x3D; 1: return &#39;&#39;</span><br><span class=\"line\">        </span><br><span class=\"line\">        def KMPSearch(pat, txt): </span><br><span class=\"line\">            M, N &#x3D; len(pat), len(txt) </span><br><span class=\"line\">            lps &#x3D; failure(pat)</span><br><span class=\"line\"></span><br><span class=\"line\">            i &#x3D; 0 # index for txt[] </span><br><span class=\"line\">            j &#x3D; 0 # index for pat[] </span><br><span class=\"line\">            while i &lt; N: </span><br><span class=\"line\">                if pat[j] &#x3D;&#x3D; txt[i]: </span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">                    j +&#x3D; 1</span><br><span class=\"line\">                elif i &lt; N and pat[j] !&#x3D; txt[i]: </span><br><span class=\"line\">                    if j !&#x3D; 0: </span><br><span class=\"line\">                        j &#x3D; lps[j-1] </span><br><span class=\"line\">                    else: </span><br><span class=\"line\">                        i +&#x3D; 1</span><br><span class=\"line\">                if i &gt;&#x3D; N:                        </span><br><span class=\"line\">                    return i - j </span><br><span class=\"line\"></span><br><span class=\"line\">        def failure(pat): </span><br><span class=\"line\">            res &#x3D; [0]</span><br><span class=\"line\">            i, target &#x3D; 1, 0</span><br><span class=\"line\">            while i &lt; len(pat): </span><br><span class=\"line\">                if pat[i]&#x3D;&#x3D; pat[target]: </span><br><span class=\"line\">                    target +&#x3D; 1</span><br><span class=\"line\">                    res +&#x3D; target,</span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">                elif target: </span><br><span class=\"line\">                    target &#x3D; res[target-1] </span><br><span class=\"line\">                else: </span><br><span class=\"line\">                    res +&#x3D; 0,</span><br><span class=\"line\">                    i +&#x3D; 1</span><br><span class=\"line\">            return res                        </span><br><span class=\"line\">                        </span><br><span class=\"line\">        l &#x3D; len(s) - 1 - KMPSearch(s[:-1], s[1:])</span><br><span class=\"line\">        return s[:l]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Max Dot Product Of Two Subsequences's Solution","date":"2020-05-24T04:13:00.000Z","_content":"\n**Original Question**: [Max Dot Product Of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648261/cpython-simple-dp)\n\n**Idea**<br>\nThis is a typical Dynamic Programming problem. The only trick lies in the **non-emptiness**.\n\n\n\n\n- Target: We want to calculate the maximal dot product for nums1[0:i] and nums2[0:j]\n<li>Base case\n<ul>\n- When `i == 0` or `j == 0`, we return -inf. (Because this is an **empty** case, which is intolerable)\n\n- `nums1[i - 1]` is not selected, `dp[i][j] = dp[i - 1][j]`\n- `nums2[j - 1]` is not selected, `dp[i][j] = dp[i][j - 1]`\n- Neither `nums1[i - 1]` or `nums2[j - 1]` is selected, `dp[i][j] = dp[i - 1][j - 1]`\n<li>Both `nums1[i - 1]` and `nums2[j - 1]` are selected, `dp[i][j] = max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]`\n<ul>\n- **Since we already selected one pair (nums1[i - 1], nums2[j - 1]), we can assume the minimal proceeding value is `0`**\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(mn)`\n- Space: `O(m)`\n\n\n\n**C++, dp**\n\n\n\n\n```\nclass Solution {\npublic:\n    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n        int n = int(nums1.size()), m = int(nums2.size());\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                dp[i][j] = max(dp[i][j], dp[i][j - 1]);\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);\n                dp[i][j] = max(dp[i][j], max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n\n```\n\n\n\n**Python 3, recursion with memoization**\n\n\n\n\n```\nfrom functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def helper(i, j):\n            if i == 0 or j == 0: return -math.inf\n            return max(helper(i - 1, j - 1), helper(i, j - 1), helper(i - 1, j),\n                       max(helper(i - 1, j - 1), 0) + nums1[i - 1] * nums2[j - 1])\n        return helper(len(nums1), len(nums2))\n\n```\n\n\n\n**Python 3, dp**\n\n\n\n\n```\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        dp = [-math.inf] * (m + 1)\n        for i in range(1, n + 1):\n            dp, old_dp = [-math.inf], dp\n            for j in range(1, m + 1):\n                dp += max(\n                    old_dp[j], # not select i\n                    dp[-1], # not select j\n                    old_dp[j - 1], # not select either\n                    max(old_dp[j - 1], 0) + nums1[i - 1] * nums2[j - 1], # select both\n                ),\n        return dp[-1]     \n\n```\n\n\n","source":"_posts/max-dot-product-of-two-subsequences.md","raw":"---\ntitle: Max Dot Product Of Two Subsequences's Solution\ndate: 2020-05-24 12:13:00\n---\n\n**Original Question**: [Max Dot Product Of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648261/cpython-simple-dp)\n\n**Idea**<br>\nThis is a typical Dynamic Programming problem. The only trick lies in the **non-emptiness**.\n\n\n\n\n- Target: We want to calculate the maximal dot product for nums1[0:i] and nums2[0:j]\n<li>Base case\n<ul>\n- When `i == 0` or `j == 0`, we return -inf. (Because this is an **empty** case, which is intolerable)\n\n- `nums1[i - 1]` is not selected, `dp[i][j] = dp[i - 1][j]`\n- `nums2[j - 1]` is not selected, `dp[i][j] = dp[i][j - 1]`\n- Neither `nums1[i - 1]` or `nums2[j - 1]` is selected, `dp[i][j] = dp[i - 1][j - 1]`\n<li>Both `nums1[i - 1]` and `nums2[j - 1]` are selected, `dp[i][j] = max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]`\n<ul>\n- **Since we already selected one pair (nums1[i - 1], nums2[j - 1]), we can assume the minimal proceeding value is `0`**\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(mn)`\n- Space: `O(m)`\n\n\n\n**C++, dp**\n\n\n\n\n```\nclass Solution {\npublic:\n    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n        int n = int(nums1.size()), m = int(nums2.size());\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= m; ++j) {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j]);\n                dp[i][j] = max(dp[i][j], dp[i][j - 1]);\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);\n                dp[i][j] = max(dp[i][j], max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n\n```\n\n\n\n**Python 3, recursion with memoization**\n\n\n\n\n```\nfrom functools import lru_cache\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        @lru_cache(None)\n        def helper(i, j):\n            if i == 0 or j == 0: return -math.inf\n            return max(helper(i - 1, j - 1), helper(i, j - 1), helper(i - 1, j),\n                       max(helper(i - 1, j - 1), 0) + nums1[i - 1] * nums2[j - 1])\n        return helper(len(nums1), len(nums2))\n\n```\n\n\n\n**Python 3, dp**\n\n\n\n\n```\nclass Solution:\n    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -> int:\n        n, m = len(nums1), len(nums2)\n        dp = [-math.inf] * (m + 1)\n        for i in range(1, n + 1):\n            dp, old_dp = [-math.inf], dp\n            for j in range(1, m + 1):\n                dp += max(\n                    old_dp[j], # not select i\n                    dp[-1], # not select j\n                    old_dp[j - 1], # not select either\n                    max(old_dp[j - 1], 0) + nums1[i - 1] * nums2[j - 1], # select both\n                ),\n        return dp[-1]     \n\n```\n\n\n","slug":"max-dot-product-of-two-subsequences","published":1,"updated":"2020-08-21T07:57:37.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrz00084iluasz80kmb","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/max-dot-product-of-two-subsequences\">Max Dot Product Of Two Subsequences</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648261/cpython-simple-dp\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical Dynamic Programming problem. The only trick lies in the <strong>non-emptiness</strong>.</p>\n<ul>\n<li><p>Target: We want to calculate the maximal dot product for nums1[0:i] and nums2[0:j]</p>\n<li>Base case\n<ul></li>\n<li><p>When <code>i == 0</code> or <code>j == 0</code>, we return -inf. (Because this is an <strong>empty</strong> case, which is intolerable)</p>\n</li>\n<li><p><code>nums1[i - 1]</code> is not selected, <code>dp[i][j] = dp[i - 1][j]</code></p>\n</li>\n<li><p><code>nums2[j - 1]</code> is not selected, <code>dp[i][j] = dp[i][j - 1]</code></p>\n</li>\n<li><p>Neither <code>nums1[i - 1]</code> or <code>nums2[j - 1]</code> is selected, <code>dp[i][j] = dp[i - 1][j - 1]</code></p>\n<li>Both `nums1[i - 1]` and `nums2[j - 1]` are selected, `dp[i][j] = max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]`\n<ul></li>\n<li><p><strong>Since we already selected one pair (nums1[i - 1], nums2[j - 1]), we can assume the minimal proceeding value is <code>0</code></strong></p>\n</li>\n</ul>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(mn)</code></li>\n<li>Space: <code>O(m)</code></li>\n</ul>\n<p><strong>C++, dp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        int n &#x3D; int(nums1.size()), m &#x3D; int(nums2.size());</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MIN));</span><br><span class=\"line\">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class=\"line\">            for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i][j - 1]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - 1]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, recursion with memoization</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import lru_cache</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class=\"line\">        @lru_cache(None)</span><br><span class=\"line\">        def helper(i, j):</span><br><span class=\"line\">            if i &#x3D;&#x3D; 0 or j &#x3D;&#x3D; 0: return -math.inf</span><br><span class=\"line\">            return max(helper(i - 1, j - 1), helper(i, j - 1), helper(i - 1, j),</span><br><span class=\"line\">                       max(helper(i - 1, j - 1), 0) + nums1[i - 1] * nums2[j - 1])</span><br><span class=\"line\">        return helper(len(nums1), len(nums2))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, dp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class=\"line\">        n, m &#x3D; len(nums1), len(nums2)</span><br><span class=\"line\">        dp &#x3D; [-math.inf] * (m + 1)</span><br><span class=\"line\">        for i in range(1, n + 1):</span><br><span class=\"line\">            dp, old_dp &#x3D; [-math.inf], dp</span><br><span class=\"line\">            for j in range(1, m + 1):</span><br><span class=\"line\">                dp +&#x3D; max(</span><br><span class=\"line\">                    old_dp[j], # not select i</span><br><span class=\"line\">                    dp[-1], # not select j</span><br><span class=\"line\">                    old_dp[j - 1], # not select either</span><br><span class=\"line\">                    max(old_dp[j - 1], 0) + nums1[i - 1] * nums2[j - 1], # select both</span><br><span class=\"line\">                ),</span><br><span class=\"line\">        return dp[-1]     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/max-dot-product-of-two-subsequences\">Max Dot Product Of Two Subsequences</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648261/cpython-simple-dp\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is a typical Dynamic Programming problem. The only trick lies in the <strong>non-emptiness</strong>.</p>\n<ul>\n<li><p>Target: We want to calculate the maximal dot product for nums1[0:i] and nums2[0:j]</p>\n<li>Base case\n<ul></li>\n<li><p>When <code>i == 0</code> or <code>j == 0</code>, we return -inf. (Because this is an <strong>empty</strong> case, which is intolerable)</p>\n</li>\n<li><p><code>nums1[i - 1]</code> is not selected, <code>dp[i][j] = dp[i - 1][j]</code></p>\n</li>\n<li><p><code>nums2[j - 1]</code> is not selected, <code>dp[i][j] = dp[i][j - 1]</code></p>\n</li>\n<li><p>Neither <code>nums1[i - 1]</code> or <code>nums2[j - 1]</code> is selected, <code>dp[i][j] = dp[i - 1][j - 1]</code></p>\n<li>Both `nums1[i - 1]` and `nums2[j - 1]` are selected, `dp[i][j] = max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]`\n<ul></li>\n<li><p><strong>Since we already selected one pair (nums1[i - 1], nums2[j - 1]), we can assume the minimal proceeding value is <code>0</code></strong></p>\n</li>\n</ul>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(mn)</code></li>\n<li>Space: <code>O(m)</code></li>\n</ul>\n<p><strong>C++, dp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class=\"line\">        int n &#x3D; int(nums1.size()), m &#x3D; int(nums2.size());</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MIN));</span><br><span class=\"line\">        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;</span><br><span class=\"line\">            for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) &#123;</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i][j - 1]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - 1]);</span><br><span class=\"line\">                dp[i][j] &#x3D; max(dp[i][j], max(dp[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, recursion with memoization</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import lru_cache</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class=\"line\">        @lru_cache(None)</span><br><span class=\"line\">        def helper(i, j):</span><br><span class=\"line\">            if i &#x3D;&#x3D; 0 or j &#x3D;&#x3D; 0: return -math.inf</span><br><span class=\"line\">            return max(helper(i - 1, j - 1), helper(i, j - 1), helper(i - 1, j),</span><br><span class=\"line\">                       max(helper(i - 1, j - 1), 0) + nums1[i - 1] * nums2[j - 1])</span><br><span class=\"line\">        return helper(len(nums1), len(nums2))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, dp</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class=\"line\">        n, m &#x3D; len(nums1), len(nums2)</span><br><span class=\"line\">        dp &#x3D; [-math.inf] * (m + 1)</span><br><span class=\"line\">        for i in range(1, n + 1):</span><br><span class=\"line\">            dp, old_dp &#x3D; [-math.inf], dp</span><br><span class=\"line\">            for j in range(1, m + 1):</span><br><span class=\"line\">                dp +&#x3D; max(</span><br><span class=\"line\">                    old_dp[j], # not select i</span><br><span class=\"line\">                    dp[-1], # not select j</span><br><span class=\"line\">                    old_dp[j - 1], # not select either</span><br><span class=\"line\">                    max(old_dp[j - 1], 0) + nums1[i - 1] * nums2[j - 1], # select both</span><br><span class=\"line\">                ),</span><br><span class=\"line\">        return dp[-1]     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Maximum Number Of Non Overlapping Substrings's Solution","date":"2020-07-19T04:18:00.000Z","_content":"\n**Original Question**: [Maximum Number Of Non Overlapping Substrings](https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/discuss/743166/O(n)-set-solution)\n\n**Idea**<br>\nThe idea is that we compute a \"feature value\" for s[0..i] for every i within [0..n-1], we then stores them in a set for quick query.\n\n\n\n\n**Complexity**<br>\nTime: O(n)<br>\nSpace: O(n)\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def maxNumOfSubstrings(self, s: str) -> List[str]:\n        cnt = collections.Counter(s)\n        feat = [0] * 26\n        seen = {(0,) * 26: 0}\n        order = []\n        full = [cnt[c] for c in string.ascii_lowercase]\n        ans = []\n        \n        for i, c in enumerate(s):\n            if c not in order: order.append(c)\n            feat[ord(c) - ord('a')] += 1                \n            tmp = feat[:]\n            for x in order[::-1]:\n                if tmp[ord(x) - ord('a')] < full[ord(x) - ord('a')]:\n                    break\n                tmp[ord(x) - ord('a')] = 0\n                if tuple(tmp) in seen:\n                    ans.append(s[seen[tuple(tmp)]: i + 1])\n                    seen = {(0) * 26: 0}\n                    order = []\n            seen[tuple(feat)] = i + 1\n        return ans\n\n```\n\n\n","source":"_posts/maximum-number-of-non-overlapping-substrings.md","raw":"---\ntitle: Maximum Number Of Non Overlapping Substrings's Solution\ndate: 2020-07-19 12:18:00\n---\n\n**Original Question**: [Maximum Number Of Non Overlapping Substrings](https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/discuss/743166/O(n)-set-solution)\n\n**Idea**<br>\nThe idea is that we compute a \"feature value\" for s[0..i] for every i within [0..n-1], we then stores them in a set for quick query.\n\n\n\n\n**Complexity**<br>\nTime: O(n)<br>\nSpace: O(n)\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def maxNumOfSubstrings(self, s: str) -> List[str]:\n        cnt = collections.Counter(s)\n        feat = [0] * 26\n        seen = {(0,) * 26: 0}\n        order = []\n        full = [cnt[c] for c in string.ascii_lowercase]\n        ans = []\n        \n        for i, c in enumerate(s):\n            if c not in order: order.append(c)\n            feat[ord(c) - ord('a')] += 1                \n            tmp = feat[:]\n            for x in order[::-1]:\n                if tmp[ord(x) - ord('a')] < full[ord(x) - ord('a')]:\n                    break\n                tmp[ord(x) - ord('a')] = 0\n                if tuple(tmp) in seen:\n                    ans.append(s[seen[tuple(tmp)]: i + 1])\n                    seen = {(0) * 26: 0}\n                    order = []\n            seen[tuple(feat)] = i + 1\n        return ans\n\n```\n\n\n","slug":"maximum-number-of-non-overlapping-substrings","published":1,"updated":"2020-08-21T07:57:37.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xykrz00094ilu3476hks1","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings\">Maximum Number Of Non Overlapping Substrings</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/discuss/743166/O(n)-set-solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The idea is that we compute a “feature value” for s[0..i] for every i within [0..n-1], we then stores them in a set for quick query.</p>\n<p><strong>Complexity</strong><br><br>Time: O(n)<br><br>Space: O(n)</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxNumOfSubstrings(self, s: str) -&gt; List[str]:</span><br><span class=\"line\">        cnt &#x3D; collections.Counter(s)</span><br><span class=\"line\">        feat &#x3D; [0] * 26</span><br><span class=\"line\">        seen &#x3D; &#123;(0,) * 26: 0&#125;</span><br><span class=\"line\">        order &#x3D; []</span><br><span class=\"line\">        full &#x3D; [cnt[c] for c in string.ascii_lowercase]</span><br><span class=\"line\">        ans &#x3D; []</span><br><span class=\"line\">        </span><br><span class=\"line\">        for i, c in enumerate(s):</span><br><span class=\"line\">            if c not in order: order.append(c)</span><br><span class=\"line\">            feat[ord(c) - ord(&#39;a&#39;)] +&#x3D; 1                </span><br><span class=\"line\">            tmp &#x3D; feat[:]</span><br><span class=\"line\">            for x in order[::-1]:</span><br><span class=\"line\">                if tmp[ord(x) - ord(&#39;a&#39;)] &lt; full[ord(x) - ord(&#39;a&#39;)]:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                tmp[ord(x) - ord(&#39;a&#39;)] &#x3D; 0</span><br><span class=\"line\">                if tuple(tmp) in seen:</span><br><span class=\"line\">                    ans.append(s[seen[tuple(tmp)]: i + 1])</span><br><span class=\"line\">                    seen &#x3D; &#123;(0) * 26: 0&#125;</span><br><span class=\"line\">                    order &#x3D; []</span><br><span class=\"line\">            seen[tuple(feat)] &#x3D; i + 1</span><br><span class=\"line\">        return ans</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings\">Maximum Number Of Non Overlapping Substrings</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/discuss/743166/O(n)-set-solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The idea is that we compute a “feature value” for s[0..i] for every i within [0..n-1], we then stores them in a set for quick query.</p>\n<p><strong>Complexity</strong><br><br>Time: O(n)<br><br>Space: O(n)</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxNumOfSubstrings(self, s: str) -&gt; List[str]:</span><br><span class=\"line\">        cnt &#x3D; collections.Counter(s)</span><br><span class=\"line\">        feat &#x3D; [0] * 26</span><br><span class=\"line\">        seen &#x3D; &#123;(0,) * 26: 0&#125;</span><br><span class=\"line\">        order &#x3D; []</span><br><span class=\"line\">        full &#x3D; [cnt[c] for c in string.ascii_lowercase]</span><br><span class=\"line\">        ans &#x3D; []</span><br><span class=\"line\">        </span><br><span class=\"line\">        for i, c in enumerate(s):</span><br><span class=\"line\">            if c not in order: order.append(c)</span><br><span class=\"line\">            feat[ord(c) - ord(&#39;a&#39;)] +&#x3D; 1                </span><br><span class=\"line\">            tmp &#x3D; feat[:]</span><br><span class=\"line\">            for x in order[::-1]:</span><br><span class=\"line\">                if tmp[ord(x) - ord(&#39;a&#39;)] &lt; full[ord(x) - ord(&#39;a&#39;)]:</span><br><span class=\"line\">                    break</span><br><span class=\"line\">                tmp[ord(x) - ord(&#39;a&#39;)] &#x3D; 0</span><br><span class=\"line\">                if tuple(tmp) in seen:</span><br><span class=\"line\">                    ans.append(s[seen[tuple(tmp)]: i + 1])</span><br><span class=\"line\">                    seen &#x3D; &#123;(0) * 26: 0&#125;</span><br><span class=\"line\">                    order &#x3D; []</span><br><span class=\"line\">            seen[tuple(feat)] &#x3D; i + 1</span><br><span class=\"line\">        return ans</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Maximum Students Taking Exam's Solution","date":"2020-02-09T07:10:00.000Z","_content":"\n**Original Question**: [Maximum Students Taking Exam](https://leetcode.com/problems/maximum-students-taking-exam)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/maximum-students-taking-exam/discuss/503558/python-15-line-simple-dp-using-yield-with-explanation)\n\n**Idea**<br>\nStarting from row 0, we enumerate all the possible combination of seats arrangements.<br>\nGiven a seats arrangement of row `n`, we can enumerate all the possible seats arrangement of row `n+1`.\n\n\n\n\n**Function `combination_row` Explanation**\n\n\n\n\n<li>Inputs:\n<ul>\n- `i`: the index of row\n- `end`: the index of seat at row i under consideration\n- `prev`: the arrangement before the current seat, represented with string. E.g. '.#.'\n- `count`: the number of students seated to the left of the current position\n- `front`: the seat arrangement of the previous row\n\n- a seat arrangements at row i\n- the corresponding number of students seated at row i\n\n\n\n**Complexity**<br>\nWorst Case Time Complexity: `O(2^m * n)` (performances are much better on average cases)<br>\nWorst Case Space Complexity: `O(2^m)` (performances are much better on average cases)\n\n\n\n\n**Python3**\n\n\n\n\n```\nclass Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        \n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and \\\n                    (not prev or prev[-1] == '#') and \\\n                    (end == 0 or front[end-1] == '#') and \\\n                    (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        new_dp = {'#'*n:0} # base case: a dummy row at the very front, with all seats broken\n        for i in range(m):\n            dp, new_dp = new_dp, {}\n            for p,sm in dp.items():\n                for k,v in combination_row(i, front=p):\n                    new_dp[k] = max(v+sm, new_dp.get(k, 0))\n        return max(new_dp.values())\n\n```\n\n\n\n**Python3 using reduce (without comment and line break)**\n\n\n\n\n```\nfrom functools import reduce\nclass Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and (not prev or prev[-1] == '#') and (end == 0 or front[end-1] == '#') and (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        dp = {'#'*n:0}\n        for i in range(m):\n            def update(d, k, v): \n                d[k] = max(d.get(k, 0), v)\n                return d\n            dp = reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front=p)), {})\n        return max(dp.values()) \n\n```\n\n\n","source":"_posts/maximum-students-taking-exam.md","raw":"---\ntitle: Maximum Students Taking Exam's Solution\ndate: 2020-02-09 15:10:00\n---\n\n**Original Question**: [Maximum Students Taking Exam](https://leetcode.com/problems/maximum-students-taking-exam)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/maximum-students-taking-exam/discuss/503558/python-15-line-simple-dp-using-yield-with-explanation)\n\n**Idea**<br>\nStarting from row 0, we enumerate all the possible combination of seats arrangements.<br>\nGiven a seats arrangement of row `n`, we can enumerate all the possible seats arrangement of row `n+1`.\n\n\n\n\n**Function `combination_row` Explanation**\n\n\n\n\n<li>Inputs:\n<ul>\n- `i`: the index of row\n- `end`: the index of seat at row i under consideration\n- `prev`: the arrangement before the current seat, represented with string. E.g. '.#.'\n- `count`: the number of students seated to the left of the current position\n- `front`: the seat arrangement of the previous row\n\n- a seat arrangements at row i\n- the corresponding number of students seated at row i\n\n\n\n**Complexity**<br>\nWorst Case Time Complexity: `O(2^m * n)` (performances are much better on average cases)<br>\nWorst Case Space Complexity: `O(2^m)` (performances are much better on average cases)\n\n\n\n\n**Python3**\n\n\n\n\n```\nclass Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        \n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and \\\n                    (not prev or prev[-1] == '#') and \\\n                    (end == 0 or front[end-1] == '#') and \\\n                    (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        new_dp = {'#'*n:0} # base case: a dummy row at the very front, with all seats broken\n        for i in range(m):\n            dp, new_dp = new_dp, {}\n            for p,sm in dp.items():\n                for k,v in combination_row(i, front=p):\n                    new_dp[k] = max(v+sm, new_dp.get(k, 0))\n        return max(new_dp.values())\n\n```\n\n\n\n**Python3 using reduce (without comment and line break)**\n\n\n\n\n```\nfrom functools import reduce\nclass Solution:\n    def maxStudents(self, seats):\n        m, n = len(seats), len(seats[0])\n        def combination_row(i, end=0, prev='', count=0, front=None):\n            if end >= n:\n                yield prev, count; return\n            elif seats[i][end] == '.' and (not prev or prev[-1] == '#') and (end == 0 or front[end-1] == '#') and (end == n-1 or front[end+1] == '#'):\n                yield from combination_row(i, end+1, prev+'.', count+1, front)\n            yield from combination_row(i, end+1, prev+'#', count, front)\n                            \n        dp = {'#'*n:0}\n        for i in range(m):\n            def update(d, k, v): \n                d[k] = max(d.get(k, 0), v)\n                return d\n            dp = reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front=p)), {})\n        return max(dp.values()) \n\n```\n\n\n","slug":"maximum-students-taking-exam","published":1,"updated":"2020-08-21T07:57:37.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks0000a4ilu3nmn2qz8","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/maximum-students-taking-exam\">Maximum Students Taking Exam</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/maximum-students-taking-exam/discuss/503558/python-15-line-simple-dp-using-yield-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Starting from row 0, we enumerate all the possible combination of seats arrangements.<br><br>Given a seats arrangement of row <code>n</code>, we can enumerate all the possible seats arrangement of row <code>n+1</code>.</p>\n<p><strong>Function <code>combination_row</code> Explanation</strong></p>\n<li>Inputs:\n<ul>\n- `i`: the index of row\n- `end`: the index of seat at row i under consideration\n- `prev`: the arrangement before the current seat, represented with string. E.g. '.#.'\n- `count`: the number of students seated to the left of the current position\n- `front`: the seat arrangement of the previous row\n\n<ul>\n<li>a seat arrangements at row i</li>\n<li>the corresponding number of students seated at row i</li>\n</ul>\n<p><strong>Complexity</strong><br><br>Worst Case Time Complexity: <code>O(2^m * n)</code> (performances are much better on average cases)<br><br>Worst Case Space Complexity: <code>O(2^m)</code> (performances are much better on average cases)</p>\n<p><strong>Python3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxStudents(self, seats):</span><br><span class=\"line\">        m, n &#x3D; len(seats), len(seats[0])</span><br><span class=\"line\">        </span><br><span class=\"line\">        def combination_row(i, end&#x3D;0, prev&#x3D;&#39;&#39;, count&#x3D;0, front&#x3D;None):</span><br><span class=\"line\">            if end &gt;&#x3D; n:</span><br><span class=\"line\">                yield prev, count; return</span><br><span class=\"line\">            elif seats[i][end] &#x3D;&#x3D; &#39;.&#39; and \\</span><br><span class=\"line\">                    (not prev or prev[-1] &#x3D;&#x3D; &#39;#&#39;) and \\</span><br><span class=\"line\">                    (end &#x3D;&#x3D; 0 or front[end-1] &#x3D;&#x3D; &#39;#&#39;) and \\</span><br><span class=\"line\">                    (end &#x3D;&#x3D; n-1 or front[end+1] &#x3D;&#x3D; &#39;#&#39;):</span><br><span class=\"line\">                yield from combination_row(i, end+1, prev+&#39;.&#39;, count+1, front)</span><br><span class=\"line\">            yield from combination_row(i, end+1, prev+&#39;#&#39;, count, front)</span><br><span class=\"line\">                            </span><br><span class=\"line\">        new_dp &#x3D; &#123;&#39;#&#39;*n:0&#125; # base case: a dummy row at the very front, with all seats broken</span><br><span class=\"line\">        for i in range(m):</span><br><span class=\"line\">            dp, new_dp &#x3D; new_dp, &#123;&#125;</span><br><span class=\"line\">            for p,sm in dp.items():</span><br><span class=\"line\">                for k,v in combination_row(i, front&#x3D;p):</span><br><span class=\"line\">                    new_dp[k] &#x3D; max(v+sm, new_dp.get(k, 0))</span><br><span class=\"line\">        return max(new_dp.values())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python3 using reduce (without comment and line break)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxStudents(self, seats):</span><br><span class=\"line\">        m, n &#x3D; len(seats), len(seats[0])</span><br><span class=\"line\">        def combination_row(i, end&#x3D;0, prev&#x3D;&#39;&#39;, count&#x3D;0, front&#x3D;None):</span><br><span class=\"line\">            if end &gt;&#x3D; n:</span><br><span class=\"line\">                yield prev, count; return</span><br><span class=\"line\">            elif seats[i][end] &#x3D;&#x3D; &#39;.&#39; and (not prev or prev[-1] &#x3D;&#x3D; &#39;#&#39;) and (end &#x3D;&#x3D; 0 or front[end-1] &#x3D;&#x3D; &#39;#&#39;) and (end &#x3D;&#x3D; n-1 or front[end+1] &#x3D;&#x3D; &#39;#&#39;):</span><br><span class=\"line\">                yield from combination_row(i, end+1, prev+&#39;.&#39;, count+1, front)</span><br><span class=\"line\">            yield from combination_row(i, end+1, prev+&#39;#&#39;, count, front)</span><br><span class=\"line\">                            </span><br><span class=\"line\">        dp &#x3D; &#123;&#39;#&#39;*n:0&#125;</span><br><span class=\"line\">        for i in range(m):</span><br><span class=\"line\">            def update(d, k, v): </span><br><span class=\"line\">                d[k] &#x3D; max(d.get(k, 0), v)</span><br><span class=\"line\">                return d</span><br><span class=\"line\">            dp &#x3D; reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front&#x3D;p)), &#123;&#125;)</span><br><span class=\"line\">        return max(dp.values()) </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/maximum-students-taking-exam\">Maximum Students Taking Exam</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/maximum-students-taking-exam/discuss/503558/python-15-line-simple-dp-using-yield-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Starting from row 0, we enumerate all the possible combination of seats arrangements.<br><br>Given a seats arrangement of row <code>n</code>, we can enumerate all the possible seats arrangement of row <code>n+1</code>.</p>\n<p><strong>Function <code>combination_row</code> Explanation</strong></p>\n<li>Inputs:\n<ul>\n- `i`: the index of row\n- `end`: the index of seat at row i under consideration\n- `prev`: the arrangement before the current seat, represented with string. E.g. '.#.'\n- `count`: the number of students seated to the left of the current position\n- `front`: the seat arrangement of the previous row\n\n<ul>\n<li>a seat arrangements at row i</li>\n<li>the corresponding number of students seated at row i</li>\n</ul>\n<p><strong>Complexity</strong><br><br>Worst Case Time Complexity: <code>O(2^m * n)</code> (performances are much better on average cases)<br><br>Worst Case Space Complexity: <code>O(2^m)</code> (performances are much better on average cases)</p>\n<p><strong>Python3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxStudents(self, seats):</span><br><span class=\"line\">        m, n &#x3D; len(seats), len(seats[0])</span><br><span class=\"line\">        </span><br><span class=\"line\">        def combination_row(i, end&#x3D;0, prev&#x3D;&#39;&#39;, count&#x3D;0, front&#x3D;None):</span><br><span class=\"line\">            if end &gt;&#x3D; n:</span><br><span class=\"line\">                yield prev, count; return</span><br><span class=\"line\">            elif seats[i][end] &#x3D;&#x3D; &#39;.&#39; and \\</span><br><span class=\"line\">                    (not prev or prev[-1] &#x3D;&#x3D; &#39;#&#39;) and \\</span><br><span class=\"line\">                    (end &#x3D;&#x3D; 0 or front[end-1] &#x3D;&#x3D; &#39;#&#39;) and \\</span><br><span class=\"line\">                    (end &#x3D;&#x3D; n-1 or front[end+1] &#x3D;&#x3D; &#39;#&#39;):</span><br><span class=\"line\">                yield from combination_row(i, end+1, prev+&#39;.&#39;, count+1, front)</span><br><span class=\"line\">            yield from combination_row(i, end+1, prev+&#39;#&#39;, count, front)</span><br><span class=\"line\">                            </span><br><span class=\"line\">        new_dp &#x3D; &#123;&#39;#&#39;*n:0&#125; # base case: a dummy row at the very front, with all seats broken</span><br><span class=\"line\">        for i in range(m):</span><br><span class=\"line\">            dp, new_dp &#x3D; new_dp, &#123;&#125;</span><br><span class=\"line\">            for p,sm in dp.items():</span><br><span class=\"line\">                for k,v in combination_row(i, front&#x3D;p):</span><br><span class=\"line\">                    new_dp[k] &#x3D; max(v+sm, new_dp.get(k, 0))</span><br><span class=\"line\">        return max(new_dp.values())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python3 using reduce (without comment and line break)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import reduce</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxStudents(self, seats):</span><br><span class=\"line\">        m, n &#x3D; len(seats), len(seats[0])</span><br><span class=\"line\">        def combination_row(i, end&#x3D;0, prev&#x3D;&#39;&#39;, count&#x3D;0, front&#x3D;None):</span><br><span class=\"line\">            if end &gt;&#x3D; n:</span><br><span class=\"line\">                yield prev, count; return</span><br><span class=\"line\">            elif seats[i][end] &#x3D;&#x3D; &#39;.&#39; and (not prev or prev[-1] &#x3D;&#x3D; &#39;#&#39;) and (end &#x3D;&#x3D; 0 or front[end-1] &#x3D;&#x3D; &#39;#&#39;) and (end &#x3D;&#x3D; n-1 or front[end+1] &#x3D;&#x3D; &#39;#&#39;):</span><br><span class=\"line\">                yield from combination_row(i, end+1, prev+&#39;.&#39;, count+1, front)</span><br><span class=\"line\">            yield from combination_row(i, end+1, prev+&#39;#&#39;, count, front)</span><br><span class=\"line\">                            </span><br><span class=\"line\">        dp &#x3D; &#123;&#39;#&#39;*n:0&#125;</span><br><span class=\"line\">        for i in range(m):</span><br><span class=\"line\">            def update(d, k, v): </span><br><span class=\"line\">                d[k] &#x3D; max(d.get(k, 0), v)</span><br><span class=\"line\">                return d</span><br><span class=\"line\">            dp &#x3D; reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front&#x3D;p)), &#123;&#125;)</span><br><span class=\"line\">        return max(dp.values()) </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Minimum Distance To Type A Word Using Two Fingers's Solution","date":"2020-01-13T11:46:00.000Z","_content":"\n**Original Question**: [Minimum Distance To Type A Word Using Two Fingers](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477684/Python-simple-DP-with-explanation-(270-ms-beats-100))\n\n**Base case**: When there is only 1 character to type, we only use 1 finger.\n\n\n\n\nFor **new case n**, we expand each case n-1 with 2 possibilities\n\n\n\n\n- type the new character using finger 1\n<li>type the new character using finger 2\n<ul>\n- if finger 2 is free, no additional distance is added\n\n\n\n**We can further improve the performance**\n\n\n\n\n- there are only 26 possible finger positions.\n- there are only 26*26 different combinations of finger movements\n\n```\nfrom functools import lru_cache\nclass Solution:\n    def minimumDistance(self, A):\n        \n        @lru_cache(maxsize=None)\n        def get_distance(current_pos, next_pos):\n            if current_pos == -1: return 0\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\n        \n        @lru_cache(maxsize=None)\n        def to_num(c):\n            return ord(c) - ord('A')\n\n        # key: (i,j) i is the position of the first finger, j is the positino of the second finger\n        dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\n        for n in [to_num(c) for c in A[1:]]:\n            new_dp = {}\n            for (f1, f2), d in dp.items():\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\n            dp = new_dp\n            \n        return min(dp.values())\n\t\t# AC: 270 ms\n\n```\n\n\n","source":"_posts/minimum-distance-to-type-a-word-using-two-fingers.md","raw":"---\ntitle: Minimum Distance To Type A Word Using Two Fingers's Solution\ndate: 2020-01-13 19:46:00\n---\n\n**Original Question**: [Minimum Distance To Type A Word Using Two Fingers](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477684/Python-simple-DP-with-explanation-(270-ms-beats-100))\n\n**Base case**: When there is only 1 character to type, we only use 1 finger.\n\n\n\n\nFor **new case n**, we expand each case n-1 with 2 possibilities\n\n\n\n\n- type the new character using finger 1\n<li>type the new character using finger 2\n<ul>\n- if finger 2 is free, no additional distance is added\n\n\n\n**We can further improve the performance**\n\n\n\n\n- there are only 26 possible finger positions.\n- there are only 26*26 different combinations of finger movements\n\n```\nfrom functools import lru_cache\nclass Solution:\n    def minimumDistance(self, A):\n        \n        @lru_cache(maxsize=None)\n        def get_distance(current_pos, next_pos):\n            if current_pos == -1: return 0\n            return abs(current_pos // 6 - next_pos // 6) + abs(current_pos % 6 - next_pos % 6)\n        \n        @lru_cache(maxsize=None)\n        def to_num(c):\n            return ord(c) - ord('A')\n\n        # key: (i,j) i is the position of the first finger, j is the positino of the second finger\n        dp = {(to_num(A[0]), -1): 0} # base case, -1 means the second finger is free\n        for n in [to_num(c) for c in A[1:]]:\n            new_dp = {}\n            for (f1, f2), d in dp.items():\n                new_dp[n, f2] = min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))\n                new_dp[f1, n] = min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))\n            dp = new_dp\n            \n        return min(dp.values())\n\t\t# AC: 270 ms\n\n```\n\n\n","slug":"minimum-distance-to-type-a-word-using-two-fingers","published":1,"updated":"2020-08-21T07:57:37.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks0000b4iluda9cgzil","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers\">Minimum Distance To Type A Word Using Two Fingers</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477684/Python-simple-DP-with-explanation-(270-ms-beats-100)\">Solution</a></p>\n<p><strong>Base case</strong>: When there is only 1 character to type, we only use 1 finger.</p>\n<p>For <strong>new case n</strong>, we expand each case n-1 with 2 possibilities</p>\n<ul>\n<li>type the new character using finger 1<li>type the new character using finger 2\n<ul></li>\n<li>if finger 2 is free, no additional distance is added</li>\n</ul>\n<p><strong>We can further improve the performance</strong></p>\n<ul>\n<li>there are only 26 possible finger positions.</li>\n<li>there are only 26*26 different combinations of finger movements</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import lru_cache</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minimumDistance(self, A):</span><br><span class=\"line\">        </span><br><span class=\"line\">        @lru_cache(maxsize&#x3D;None)</span><br><span class=\"line\">        def get_distance(current_pos, next_pos):</span><br><span class=\"line\">            if current_pos &#x3D;&#x3D; -1: return 0</span><br><span class=\"line\">            return abs(current_pos &#x2F;&#x2F; 6 - next_pos &#x2F;&#x2F; 6) + abs(current_pos % 6 - next_pos % 6)</span><br><span class=\"line\">        </span><br><span class=\"line\">        @lru_cache(maxsize&#x3D;None)</span><br><span class=\"line\">        def to_num(c):</span><br><span class=\"line\">            return ord(c) - ord(&#39;A&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">        # key: (i,j) i is the position of the first finger, j is the positino of the second finger</span><br><span class=\"line\">        dp &#x3D; &#123;(to_num(A[0]), -1): 0&#125; # base case, -1 means the second finger is free</span><br><span class=\"line\">        for n in [to_num(c) for c in A[1:]]:</span><br><span class=\"line\">            new_dp &#x3D; &#123;&#125;</span><br><span class=\"line\">            for (f1, f2), d in dp.items():</span><br><span class=\"line\">                new_dp[n, f2] &#x3D; min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))</span><br><span class=\"line\">                new_dp[f1, n] &#x3D; min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))</span><br><span class=\"line\">            dp &#x3D; new_dp</span><br><span class=\"line\">            </span><br><span class=\"line\">        return min(dp.values())</span><br><span class=\"line\">        # AC: 270 ms</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers\">Minimum Distance To Type A Word Using Two Fingers</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/discuss/477684/Python-simple-DP-with-explanation-(270-ms-beats-100)\">Solution</a></p>\n<p><strong>Base case</strong>: When there is only 1 character to type, we only use 1 finger.</p>\n<p>For <strong>new case n</strong>, we expand each case n-1 with 2 possibilities</p>\n<ul>\n<li>type the new character using finger 1<li>type the new character using finger 2\n<ul></li>\n<li>if finger 2 is free, no additional distance is added</li>\n</ul>\n<p><strong>We can further improve the performance</strong></p>\n<ul>\n<li>there are only 26 possible finger positions.</li>\n<li>there are only 26*26 different combinations of finger movements</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from functools import lru_cache</span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minimumDistance(self, A):</span><br><span class=\"line\">        </span><br><span class=\"line\">        @lru_cache(maxsize&#x3D;None)</span><br><span class=\"line\">        def get_distance(current_pos, next_pos):</span><br><span class=\"line\">            if current_pos &#x3D;&#x3D; -1: return 0</span><br><span class=\"line\">            return abs(current_pos &#x2F;&#x2F; 6 - next_pos &#x2F;&#x2F; 6) + abs(current_pos % 6 - next_pos % 6)</span><br><span class=\"line\">        </span><br><span class=\"line\">        @lru_cache(maxsize&#x3D;None)</span><br><span class=\"line\">        def to_num(c):</span><br><span class=\"line\">            return ord(c) - ord(&#39;A&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">        # key: (i,j) i is the position of the first finger, j is the positino of the second finger</span><br><span class=\"line\">        dp &#x3D; &#123;(to_num(A[0]), -1): 0&#125; # base case, -1 means the second finger is free</span><br><span class=\"line\">        for n in [to_num(c) for c in A[1:]]:</span><br><span class=\"line\">            new_dp &#x3D; &#123;&#125;</span><br><span class=\"line\">            for (f1, f2), d in dp.items():</span><br><span class=\"line\">                new_dp[n, f2] &#x3D; min(new_dp.get((n, f2), math.inf), d + get_distance(f1, n))</span><br><span class=\"line\">                new_dp[f1, n] &#x3D; min(new_dp.get((f1, n), math.inf), d + get_distance(f2, n))</span><br><span class=\"line\">            dp &#x3D; new_dp</span><br><span class=\"line\">            </span><br><span class=\"line\">        return min(dp.values())</span><br><span class=\"line\">        # AC: 270 ms</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Minimum Number Of Increments On Subarrays To Form A Target Array's Solution","date":"2020-07-29T14:56:00.000Z","_content":"\n**Original Question**: [Minimum Number Of Increments On Subarrays To Form A Target Array](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/discuss/754630/C%2B%2BPython-1-line-Greedy-Solution)\n\n**Idea**<br>\nTraversing through the array is like travelling through a collection of mountains.<br>\nWhenever we are going downwards, we have to remove the peak we've passed.<br>\nIt is obvious that a single peak of height `h` can be taken down with `h` movements.\n\n\n\n\nPlease upvote if you find this post helpful or interesting. It means a lot to me. Thx~\n\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(n)`\n- Space: Constant\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return sum(max(target[i - 1] - target[i], 0) for i in range(1, len(target))) + target[-1]\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int minNumberOperations(vector<int>& target) {\n        int res = 0;\n        vector<int> increase;\n        target.push_back(0);\n        for (auto x: target){\n            if (!increase.empty() && increase.back() > x)\n                res += increase.back() - x;\n            while (!increase.empty() && increase.back() >= x)\n                increase.pop_back();\n            increase.push_back(x);\n        }\n        return res;\n    }\n};\n\n```\n\n\n","source":"_posts/minimum-number-of-increments-on-subarrays-to-form-a-target-array.md","raw":"---\ntitle: Minimum Number Of Increments On Subarrays To Form A Target Array's Solution\ndate: 2020-07-29 22:56:00\n---\n\n**Original Question**: [Minimum Number Of Increments On Subarrays To Form A Target Array](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/discuss/754630/C%2B%2BPython-1-line-Greedy-Solution)\n\n**Idea**<br>\nTraversing through the array is like travelling through a collection of mountains.<br>\nWhenever we are going downwards, we have to remove the peak we've passed.<br>\nIt is obvious that a single peak of height `h` can be taken down with `h` movements.\n\n\n\n\nPlease upvote if you find this post helpful or interesting. It means a lot to me. Thx~\n\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(n)`\n- Space: Constant\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def minNumberOperations(self, target: List[int]) -> int:\n        return sum(max(target[i - 1] - target[i], 0) for i in range(1, len(target))) + target[-1]\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int minNumberOperations(vector<int>& target) {\n        int res = 0;\n        vector<int> increase;\n        target.push_back(0);\n        for (auto x: target){\n            if (!increase.empty() && increase.back() > x)\n                res += increase.back() - x;\n            while (!increase.empty() && increase.back() >= x)\n                increase.pop_back();\n            increase.push_back(x);\n        }\n        return res;\n    }\n};\n\n```\n\n\n","slug":"minimum-number-of-increments-on-subarrays-to-form-a-target-array","published":1,"updated":"2020-08-21T07:57:37.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks2000c4ilu6pnlb62s","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array\">Minimum Number Of Increments On Subarrays To Form A Target Array</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/discuss/754630/C%2B%2BPython-1-line-Greedy-Solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Traversing through the array is like travelling through a collection of mountains.<br><br>Whenever we are going downwards, we have to remove the peak we’ve passed.<br><br>It is obvious that a single peak of height <code>h</code> can be taken down with <code>h</code> movements.</p>\n<p>Please upvote if you find this post helpful or interesting. It means a lot to me. Thx~</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(n)</code></li>\n<li>Space: Constant</li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minNumberOperations(self, target: List[int]) -&gt; int:</span><br><span class=\"line\">        return sum(max(target[i - 1] - target[i], 0) for i in range(1, len(target))) + target[-1]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int minNumberOperations(vector&lt;int&gt;&amp; target) &#123;</span><br><span class=\"line\">        int res &#x3D; 0;</span><br><span class=\"line\">        vector&lt;int&gt; increase;</span><br><span class=\"line\">        target.push_back(0);</span><br><span class=\"line\">        for (auto x: target)&#123;</span><br><span class=\"line\">            if (!increase.empty() &amp;&amp; increase.back() &gt; x)</span><br><span class=\"line\">                res +&#x3D; increase.back() - x;</span><br><span class=\"line\">            while (!increase.empty() &amp;&amp; increase.back() &gt;&#x3D; x)</span><br><span class=\"line\">                increase.pop_back();</span><br><span class=\"line\">            increase.push_back(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array\">Minimum Number Of Increments On Subarrays To Form A Target Array</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/discuss/754630/C%2B%2BPython-1-line-Greedy-Solution\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Traversing through the array is like travelling through a collection of mountains.<br><br>Whenever we are going downwards, we have to remove the peak we’ve passed.<br><br>It is obvious that a single peak of height <code>h</code> can be taken down with <code>h</code> movements.</p>\n<p>Please upvote if you find this post helpful or interesting. It means a lot to me. Thx~</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(n)</code></li>\n<li>Space: Constant</li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minNumberOperations(self, target: List[int]) -&gt; int:</span><br><span class=\"line\">        return sum(max(target[i - 1] - target[i], 0) for i in range(1, len(target))) + target[-1]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int minNumberOperations(vector&lt;int&gt;&amp; target) &#123;</span><br><span class=\"line\">        int res &#x3D; 0;</span><br><span class=\"line\">        vector&lt;int&gt; increase;</span><br><span class=\"line\">        target.push_back(0);</span><br><span class=\"line\">        for (auto x: target)&#123;</span><br><span class=\"line\">            if (!increase.empty() &amp;&amp; increase.back() &gt; x)</span><br><span class=\"line\">                res +&#x3D; increase.back() - x;</span><br><span class=\"line\">            while (!increase.empty() &amp;&amp; increase.back() &gt;&#x3D; x)</span><br><span class=\"line\">                increase.pop_back();</span><br><span class=\"line\">            increase.push_back(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Minimum Number Of Taps To Open To Water A Garden's Solution","date":"2020-01-19T06:08:00.000Z","_content":"\n**Original Question**: [Minimum Number Of Taps To Open To Water A Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/484272/python-o1-memory-on-time-greedy-with-explanation-132ms-beats-100)\n\n**Constant Space! O(n) Greedy Approuch (AC: 132ms beats 100%)**<br>\nThis question is very similar to [Jump Game II](https://leetcode.com/problems/jump-game-ii/).\n\n\n\n\n1. Inplace modify `ranges` so that each element represents the furthest index you can reach by taking one jump.\n1. Find the minimal jump you need to reach the end.\n\n```\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i,r in enumerate(ranges):\n            l = max(0,i-r)\n            ranges[l] = max(i+r, ranges[l])\n            \n        res = lo = hi = 0            \n        while hi < n:\n            lo, hi = hi, max(ranges[lo:hi+1])\n            if hi == lo: return -1\n            res += 1\n        return res  \n\n```\n\n\n\n**O(nlogn) Greedy Approuch (AC: 175ms)**\n\n\n\n\n1. Convert `ranges` in the format of `[(l0,r0), (l1,r1)...]`, where `li,ri` represents the left boundary and right boundary of a tap. O(n)\n1. Sort the taps. O(nlogn)\n1. Select taps greedily. We select the one that can reach the furthest among those whose left boundary overlaps with the current furthest point.\n\n```\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        taps = sorted([(max(p-r,0), min(p+r,n)) for p, r in enumerate(ranges)])\n        \n        new_furthest = furthest = ind = 0\n        for res in range(1,n+1):\n            for i,(l,r) in enumerate(taps[ind:],ind):\n                if l > furthest: break\n                new_furthest = max(new_furthest, r)\n            ind = i                \n                \n            if new_furthest == furthest and new_furthest != n: return -1\n            if new_furthest == n: return res\n            furthest = new_furthest\n\n```\n\n\n","source":"_posts/minimum-number-of-taps-to-open-to-water-a-garden.md","raw":"---\ntitle: Minimum Number Of Taps To Open To Water A Garden's Solution\ndate: 2020-01-19 14:08:00\n---\n\n**Original Question**: [Minimum Number Of Taps To Open To Water A Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/484272/python-o1-memory-on-time-greedy-with-explanation-132ms-beats-100)\n\n**Constant Space! O(n) Greedy Approuch (AC: 132ms beats 100%)**<br>\nThis question is very similar to [Jump Game II](https://leetcode.com/problems/jump-game-ii/).\n\n\n\n\n1. Inplace modify `ranges` so that each element represents the furthest index you can reach by taking one jump.\n1. Find the minimal jump you need to reach the end.\n\n```\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        for i,r in enumerate(ranges):\n            l = max(0,i-r)\n            ranges[l] = max(i+r, ranges[l])\n            \n        res = lo = hi = 0            \n        while hi < n:\n            lo, hi = hi, max(ranges[lo:hi+1])\n            if hi == lo: return -1\n            res += 1\n        return res  \n\n```\n\n\n\n**O(nlogn) Greedy Approuch (AC: 175ms)**\n\n\n\n\n1. Convert `ranges` in the format of `[(l0,r0), (l1,r1)...]`, where `li,ri` represents the left boundary and right boundary of a tap. O(n)\n1. Sort the taps. O(nlogn)\n1. Select taps greedily. We select the one that can reach the furthest among those whose left boundary overlaps with the current furthest point.\n\n```\nclass Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        taps = sorted([(max(p-r,0), min(p+r,n)) for p, r in enumerate(ranges)])\n        \n        new_furthest = furthest = ind = 0\n        for res in range(1,n+1):\n            for i,(l,r) in enumerate(taps[ind:],ind):\n                if l > furthest: break\n                new_furthest = max(new_furthest, r)\n            ind = i                \n                \n            if new_furthest == furthest and new_furthest != n: return -1\n            if new_furthest == n: return res\n            furthest = new_furthest\n\n```\n\n\n","slug":"minimum-number-of-taps-to-open-to-water-a-garden","published":1,"updated":"2020-08-21T07:57:37.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks2000d4ilu5ul3a3ly","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden\">Minimum Number Of Taps To Open To Water A Garden</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/484272/python-o1-memory-on-time-greedy-with-explanation-132ms-beats-100\">Solution</a></p>\n<p><strong>Constant Space! O(n) Greedy Approuch (AC: 132ms beats 100%)</strong><br><br>This question is very similar to <a href=\"https://leetcode.com/problems/jump-game-ii/\">Jump Game II</a>.</p>\n<ol>\n<li>Inplace modify <code>ranges</code> so that each element represents the furthest index you can reach by taking one jump.</li>\n<li>Find the minimal jump you need to reach the end.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minTaps(self, n: int, ranges: List[int]) -&gt; int:</span><br><span class=\"line\">        for i,r in enumerate(ranges):</span><br><span class=\"line\">            l &#x3D; max(0,i-r)</span><br><span class=\"line\">            ranges[l] &#x3D; max(i+r, ranges[l])</span><br><span class=\"line\">            </span><br><span class=\"line\">        res &#x3D; lo &#x3D; hi &#x3D; 0            </span><br><span class=\"line\">        while hi &lt; n:</span><br><span class=\"line\">            lo, hi &#x3D; hi, max(ranges[lo:hi+1])</span><br><span class=\"line\">            if hi &#x3D;&#x3D; lo: return -1</span><br><span class=\"line\">            res +&#x3D; 1</span><br><span class=\"line\">        return res  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>O(nlogn) Greedy Approuch (AC: 175ms)</strong></p>\n<ol>\n<li>Convert <code>ranges</code> in the format of <code>[(l0,r0), (l1,r1)...]</code>, where <code>li,ri</code> represents the left boundary and right boundary of a tap. O(n)</li>\n<li>Sort the taps. O(nlogn)</li>\n<li>Select taps greedily. We select the one that can reach the furthest among those whose left boundary overlaps with the current furthest point.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minTaps(self, n: int, ranges: List[int]) -&gt; int:</span><br><span class=\"line\">        taps &#x3D; sorted([(max(p-r,0), min(p+r,n)) for p, r in enumerate(ranges)])</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_furthest &#x3D; furthest &#x3D; ind &#x3D; 0</span><br><span class=\"line\">        for res in range(1,n+1):</span><br><span class=\"line\">            for i,(l,r) in enumerate(taps[ind:],ind):</span><br><span class=\"line\">                if l &gt; furthest: break</span><br><span class=\"line\">                new_furthest &#x3D; max(new_furthest, r)</span><br><span class=\"line\">            ind &#x3D; i                </span><br><span class=\"line\">                </span><br><span class=\"line\">            if new_furthest &#x3D;&#x3D; furthest and new_furthest !&#x3D; n: return -1</span><br><span class=\"line\">            if new_furthest &#x3D;&#x3D; n: return res</span><br><span class=\"line\">            furthest &#x3D; new_furthest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden\">Minimum Number Of Taps To Open To Water A Garden</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/484272/python-o1-memory-on-time-greedy-with-explanation-132ms-beats-100\">Solution</a></p>\n<p><strong>Constant Space! O(n) Greedy Approuch (AC: 132ms beats 100%)</strong><br><br>This question is very similar to <a href=\"https://leetcode.com/problems/jump-game-ii/\">Jump Game II</a>.</p>\n<ol>\n<li>Inplace modify <code>ranges</code> so that each element represents the furthest index you can reach by taking one jump.</li>\n<li>Find the minimal jump you need to reach the end.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minTaps(self, n: int, ranges: List[int]) -&gt; int:</span><br><span class=\"line\">        for i,r in enumerate(ranges):</span><br><span class=\"line\">            l &#x3D; max(0,i-r)</span><br><span class=\"line\">            ranges[l] &#x3D; max(i+r, ranges[l])</span><br><span class=\"line\">            </span><br><span class=\"line\">        res &#x3D; lo &#x3D; hi &#x3D; 0            </span><br><span class=\"line\">        while hi &lt; n:</span><br><span class=\"line\">            lo, hi &#x3D; hi, max(ranges[lo:hi+1])</span><br><span class=\"line\">            if hi &#x3D;&#x3D; lo: return -1</span><br><span class=\"line\">            res +&#x3D; 1</span><br><span class=\"line\">        return res  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>O(nlogn) Greedy Approuch (AC: 175ms)</strong></p>\n<ol>\n<li>Convert <code>ranges</code> in the format of <code>[(l0,r0), (l1,r1)...]</code>, where <code>li,ri</code> represents the left boundary and right boundary of a tap. O(n)</li>\n<li>Sort the taps. O(nlogn)</li>\n<li>Select taps greedily. We select the one that can reach the furthest among those whose left boundary overlaps with the current furthest point.</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minTaps(self, n: int, ranges: List[int]) -&gt; int:</span><br><span class=\"line\">        taps &#x3D; sorted([(max(p-r,0), min(p+r,n)) for p, r in enumerate(ranges)])</span><br><span class=\"line\">        </span><br><span class=\"line\">        new_furthest &#x3D; furthest &#x3D; ind &#x3D; 0</span><br><span class=\"line\">        for res in range(1,n+1):</span><br><span class=\"line\">            for i,(l,r) in enumerate(taps[ind:],ind):</span><br><span class=\"line\">                if l &gt; furthest: break</span><br><span class=\"line\">                new_furthest &#x3D; max(new_furthest, r)</span><br><span class=\"line\">            ind &#x3D; i                </span><br><span class=\"line\">                </span><br><span class=\"line\">            if new_furthest &#x3D;&#x3D; furthest and new_furthest !&#x3D; n: return -1</span><br><span class=\"line\">            if new_furthest &#x3D;&#x3D; n: return res</span><br><span class=\"line\">            furthest &#x3D; new_furthest</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Minimum Possible Integer After At Most K Adjacent Swaps On Digits's Solution","date":"2020-07-05T04:03:00.000Z","_content":"\n**Original Question**: [Minimum Possible Integer After At Most K Adjacent Swaps On Digits](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720127/python-bytedance-interview-question)\n\n**Idea**<br>\nGreedily select the smallest number we can reach, and push it all the way to the front.\n\n\n\n\n**Complexity**\n\n\n\n\n- time: O(n^2)\n- space: O(n)\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        num = [*map(int, num)]\n        if k >= (len(num) ** 2) // 2:\n            return ''.join(map(str, sorted(num)))\n        \n        res = []\n        q = [(v, i) for i, v in enumerate(num)]\n        while k and q:\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\n            k -= idx\n            del q[idx]\n            res += v,\n            \n        res += [v for v, _ in q]\n        return ''.join(map(str, res))\n\n```\n\n\n\nPlease please don't downvote unless necessary bro.\n","source":"_posts/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.md","raw":"---\ntitle: Minimum Possible Integer After At Most K Adjacent Swaps On Digits's Solution\ndate: 2020-07-05 12:03:00\n---\n\n**Original Question**: [Minimum Possible Integer After At Most K Adjacent Swaps On Digits](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720127/python-bytedance-interview-question)\n\n**Idea**<br>\nGreedily select the smallest number we can reach, and push it all the way to the front.\n\n\n\n\n**Complexity**\n\n\n\n\n- time: O(n^2)\n- space: O(n)\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def minInteger(self, num: str, k: int) -> str:\n        num = [*map(int, num)]\n        if k >= (len(num) ** 2) // 2:\n            return ''.join(map(str, sorted(num)))\n        \n        res = []\n        q = [(v, i) for i, v in enumerate(num)]\n        while k and q:\n            idx, (v, i) = min(enumerate(q[:k + 1]), key=lambda p:p[1])\n            k -= idx\n            del q[idx]\n            res += v,\n            \n        res += [v for v, _ in q]\n        return ''.join(map(str, res))\n\n```\n\n\n\nPlease please don't downvote unless necessary bro.\n","slug":"minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits","published":1,"updated":"2020-08-21T07:57:37.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks3000e4ilue0ih74l6","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits\">Minimum Possible Integer After At Most K Adjacent Swaps On Digits</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720127/python-bytedance-interview-question\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Greedily select the smallest number we can reach, and push it all the way to the front.</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>time: O(n^2)</li>\n<li>space: O(n)</li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minInteger(self, num: str, k: int) -&gt; str:</span><br><span class=\"line\">        num &#x3D; [*map(int, num)]</span><br><span class=\"line\">        if k &gt;&#x3D; (len(num) ** 2) &#x2F;&#x2F; 2:</span><br><span class=\"line\">            return &#39;&#39;.join(map(str, sorted(num)))</span><br><span class=\"line\">        </span><br><span class=\"line\">        res &#x3D; []</span><br><span class=\"line\">        q &#x3D; [(v, i) for i, v in enumerate(num)]</span><br><span class=\"line\">        while k and q:</span><br><span class=\"line\">            idx, (v, i) &#x3D; min(enumerate(q[:k + 1]), key&#x3D;lambda p:p[1])</span><br><span class=\"line\">            k -&#x3D; idx</span><br><span class=\"line\">            del q[idx]</span><br><span class=\"line\">            res +&#x3D; v,</span><br><span class=\"line\">            </span><br><span class=\"line\">        res +&#x3D; [v for v, _ in q]</span><br><span class=\"line\">        return &#39;&#39;.join(map(str, res))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Please please don’t downvote unless necessary bro.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits\">Minimum Possible Integer After At Most K Adjacent Swaps On Digits</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/discuss/720127/python-bytedance-interview-question\">Solution</a></p>\n<p><strong>Idea</strong><br><br>Greedily select the smallest number we can reach, and push it all the way to the front.</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>time: O(n^2)</li>\n<li>space: O(n)</li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def minInteger(self, num: str, k: int) -&gt; str:</span><br><span class=\"line\">        num &#x3D; [*map(int, num)]</span><br><span class=\"line\">        if k &gt;&#x3D; (len(num) ** 2) &#x2F;&#x2F; 2:</span><br><span class=\"line\">            return &#39;&#39;.join(map(str, sorted(num)))</span><br><span class=\"line\">        </span><br><span class=\"line\">        res &#x3D; []</span><br><span class=\"line\">        q &#x3D; [(v, i) for i, v in enumerate(num)]</span><br><span class=\"line\">        while k and q:</span><br><span class=\"line\">            idx, (v, i) &#x3D; min(enumerate(q[:k + 1]), key&#x3D;lambda p:p[1])</span><br><span class=\"line\">            k -&#x3D; idx</span><br><span class=\"line\">            del q[idx]</span><br><span class=\"line\">            res +&#x3D; v,</span><br><span class=\"line\">            </span><br><span class=\"line\">        res +&#x3D; [v for v, _ in q]</span><br><span class=\"line\">        return &#39;&#39;.join(map(str, res))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>Please please don’t downvote unless necessary bro.</p>\n"},{"title":"Number Of Sub Arrays With Odd Sum's Solution","date":"2020-07-25T16:11:00.000Z","_content":"\n**Original Question**: [Number Of Sub Arrays With Odd Sum](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/754721/C%2B%2BPython-7-line-Intuitive-Constant-Space-DP)\n\n**Idea**<br>\nThis is an elementary dynamic programming problem.<br>\n`odd[i]` records the number of subarray ending at `arr[i]` that has odd sum.<br>\n`even[i]` records the number of subarray ending at `arr[i]` that has even sum.<br>\nif arr[i + 1] is odd, `odd[i + 1] = even[i] + 1` and `even[i + 1] = odd[i]`<br>\nif arr[i + 1] is even, `odd[i + 1] = odd[i]` and `even[i + 1] = even[i] + 1`<br>\nSince we only required the previous value in `odd` and `even`, we only need `O(1)` space.\n\n\n\n\nPlease upvote if you find this post helpful or interesting. It means a lot to me. Thx~\n\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(n)`\n- Space: `O(1)`\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        res = odd = even = 0\n        for x in arr:\n            even += 1\n            if x % 2:\n                odd, even = even, odd\n            res = (res + odd) % 1000000007             \n        return res            \n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numOfSubarrays(vector<int>& arr) {\n        int res = 0, odd = 0, even = 0;\n        for (auto x: arr) {\n            even += 1;\n            if (x % 2)\n                swap(odd, even);\n            res = (res + odd) % 1000000007;\n        }\n        return res;\n    }\n};\n\n```\n\n\n","source":"_posts/number-of-sub-arrays-with-odd-sum.md","raw":"---\ntitle: Number Of Sub Arrays With Odd Sum's Solution\ndate: 2020-07-26 00:11:00\n---\n\n**Original Question**: [Number Of Sub Arrays With Odd Sum](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/754721/C%2B%2BPython-7-line-Intuitive-Constant-Space-DP)\n\n**Idea**<br>\nThis is an elementary dynamic programming problem.<br>\n`odd[i]` records the number of subarray ending at `arr[i]` that has odd sum.<br>\n`even[i]` records the number of subarray ending at `arr[i]` that has even sum.<br>\nif arr[i + 1] is odd, `odd[i + 1] = even[i] + 1` and `even[i + 1] = odd[i]`<br>\nif arr[i + 1] is even, `odd[i + 1] = odd[i]` and `even[i + 1] = even[i] + 1`<br>\nSince we only required the previous value in `odd` and `even`, we only need `O(1)` space.\n\n\n\n\nPlease upvote if you find this post helpful or interesting. It means a lot to me. Thx~\n\n\n\n\n**Complexity**\n\n\n\n\n- Time: `O(n)`\n- Space: `O(1)`\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def numOfSubarrays(self, arr: List[int]) -> int:\n        res = odd = even = 0\n        for x in arr:\n            even += 1\n            if x % 2:\n                odd, even = even, odd\n            res = (res + odd) % 1000000007             \n        return res            \n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numOfSubarrays(vector<int>& arr) {\n        int res = 0, odd = 0, even = 0;\n        for (auto x: arr) {\n            even += 1;\n            if (x % 2)\n                swap(odd, even);\n            res = (res + odd) % 1000000007;\n        }\n        return res;\n    }\n};\n\n```\n\n\n","slug":"number-of-sub-arrays-with-odd-sum","published":1,"updated":"2020-08-21T07:57:37.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks4000f4ilu5zcf304k","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum\">Number Of Sub Arrays With Odd Sum</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/754721/C%2B%2BPython-7-line-Intuitive-Constant-Space-DP\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is an elementary dynamic programming problem.<br><br><code>odd[i]</code> records the number of subarray ending at <code>arr[i]</code> that has odd sum.<br><br><code>even[i]</code> records the number of subarray ending at <code>arr[i]</code> that has even sum.<br><br>if arr[i + 1] is odd, <code>odd[i + 1] = even[i] + 1</code> and <code>even[i + 1] = odd[i]</code><br><br>if arr[i + 1] is even, <code>odd[i + 1] = odd[i]</code> and <code>even[i + 1] = even[i] + 1</code><br><br>Since we only required the previous value in <code>odd</code> and <code>even</code>, we only need <code>O(1)</code> space.</p>\n<p>Please upvote if you find this post helpful or interesting. It means a lot to me. Thx~</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(n)</code></li>\n<li>Space: <code>O(1)</code></li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numOfSubarrays(self, arr: List[int]) -&gt; int:</span><br><span class=\"line\">        res &#x3D; odd &#x3D; even &#x3D; 0</span><br><span class=\"line\">        for x in arr:</span><br><span class=\"line\">            even +&#x3D; 1</span><br><span class=\"line\">            if x % 2:</span><br><span class=\"line\">                odd, even &#x3D; even, odd</span><br><span class=\"line\">            res &#x3D; (res + odd) % 1000000007             </span><br><span class=\"line\">        return res            </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numOfSubarrays(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class=\"line\">        int res &#x3D; 0, odd &#x3D; 0, even &#x3D; 0;</span><br><span class=\"line\">        for (auto x: arr) &#123;</span><br><span class=\"line\">            even +&#x3D; 1;</span><br><span class=\"line\">            if (x % 2)</span><br><span class=\"line\">                swap(odd, even);</span><br><span class=\"line\">            res &#x3D; (res + odd) % 1000000007;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum\">Number Of Sub Arrays With Odd Sum</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/754721/C%2B%2BPython-7-line-Intuitive-Constant-Space-DP\">Solution</a></p>\n<p><strong>Idea</strong><br><br>This is an elementary dynamic programming problem.<br><br><code>odd[i]</code> records the number of subarray ending at <code>arr[i]</code> that has odd sum.<br><br><code>even[i]</code> records the number of subarray ending at <code>arr[i]</code> that has even sum.<br><br>if arr[i + 1] is odd, <code>odd[i + 1] = even[i] + 1</code> and <code>even[i + 1] = odd[i]</code><br><br>if arr[i + 1] is even, <code>odd[i + 1] = odd[i]</code> and <code>even[i + 1] = even[i] + 1</code><br><br>Since we only required the previous value in <code>odd</code> and <code>even</code>, we only need <code>O(1)</code> space.</p>\n<p>Please upvote if you find this post helpful or interesting. It means a lot to me. Thx~</p>\n<p><strong>Complexity</strong></p>\n<ul>\n<li>Time: <code>O(n)</code></li>\n<li>Space: <code>O(1)</code></li>\n</ul>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numOfSubarrays(self, arr: List[int]) -&gt; int:</span><br><span class=\"line\">        res &#x3D; odd &#x3D; even &#x3D; 0</span><br><span class=\"line\">        for x in arr:</span><br><span class=\"line\">            even +&#x3D; 1</span><br><span class=\"line\">            if x % 2:</span><br><span class=\"line\">                odd, even &#x3D; even, odd</span><br><span class=\"line\">            res &#x3D; (res + odd) % 1000000007             </span><br><span class=\"line\">        return res            </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numOfSubarrays(vector&lt;int&gt;&amp; arr) &#123;</span><br><span class=\"line\">        int res &#x3D; 0, odd &#x3D; 0, even &#x3D; 0;</span><br><span class=\"line\">        for (auto x: arr) &#123;</span><br><span class=\"line\">            even +&#x3D; 1;</span><br><span class=\"line\">            if (x % 2)</span><br><span class=\"line\">                swap(odd, even);</span><br><span class=\"line\">            res &#x3D; (res + odd) % 1000000007;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Number Of Ways To Paint N 3 Grid's Solution","date":"2020-04-12T04:08:00.000Z","_content":"\n**Original Question**: [Number Of Ways To Paint N 3 Grid](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/discuss/574876/PythonC%2B%2B-Simple-state-compression-DP-O(1)-space)\n\n**Idea**<br>\nAs shown in the first example, there are 12 possible states for a single row and let's name them as `states0, states1, ... states11`. Intuitively we should construct a `dp[i][state]` denoting the number of ways to paint i * 3 grid, with the last row in `state`.<br>\n<img src=\"https://assets.leetcode.com/users/yanrcheng2/image_1586664387.png\" alt=\"image\">\n\n\n\n\nWe first compute the compatibilities of different states. 2 states are compatible if and only if no adjacent grid between them are in the same colour. The full compatibility list are given below.\n\n\n\n\n**Full Compatibility List:**\n\n\n\n\n```\n[\n\t[1, 2, 4, 5, 10], \n\t[0, 3, 6, 8, 11], \n\t[0, 3, 6, 7], \n\t[1, 2, 7, 10], \n\t[0, 6, 8, 9], \n\t[0, 6, 7, 9, 10], \n\t[1, 2, 4, 5, 11], \n\t[2, 3, 5, 11], \n\t[1, 4, 9, 10], \n\t[4, 5, 8, 11], \n\t[0, 3, 5, 8, 11], \n\t[1, 6, 7, 9, 10]\n]\n\n```\n\n\n\nWe then have `dp[i][state] = sum(dp[i - 1][state'])` where `state'` are compatible with `state`\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(1)`\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def numOfWays(self, n: int) -> int:\n        MOD = 1000000007\n        P = ['ryr', 'yry', 'gry', 'ryg', 'yrg', 'grg', 'rgr', 'ygr', 'gyr', 'rgy', 'ygy', 'gyg']\n        nei = [[i for i, x in enumerate(P) if all(a != b for a, b in zip(x, p))] for p in P]\n        \n        dp = [1] * 12\n        for i in range(n - 1):\n            dp = [sum(dp[j] for j in nei[i]) % MOD for i in range(12)]\n        return sum(dp) % MOD\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numOfWays(int n) {\n        vector<vector<int>> compatibility {\n            {1, 2, 4, 5, 10}, \n            {0, 3, 6, 8, 11}, \n            {0, 3, 6, 7}, \n            {1, 2, 7, 10}, \n            {0, 6, 8, 9}, \n            {0, 6, 7, 9, 10}, \n            {1, 2, 4, 5, 11}, \n            {2, 3, 5, 11}, \n            {1, 4, 9, 10}, \n            {4, 5, 8, 11}, \n            {0, 3, 5, 8, 11}, \n            {1, 6, 7, 9, 10}\n        };\n        auto addMod = [&](int a, int b){return (a + b) % 1000000007;};\n        array<int, 12> dp, old;\n        dp.fill(1);\n        while (--n > 0) {\n            old = dp, dp.fill(0);\n            for (int i=0; i < 12; ++i)\n                for (int j=0; j < compatibility[i].size(); ++j)\n                    dp[i] = addMod(dp[i], old[compatibility[i][j]]);\n        }\n        return accumulate(dp.begin(), dp.end(), 0, addMod);\n    }\n};\n\n```\n\n\n","source":"_posts/number-of-ways-to-paint-n-3-grid.md","raw":"---\ntitle: Number Of Ways To Paint N 3 Grid's Solution\ndate: 2020-04-12 12:08:00\n---\n\n**Original Question**: [Number Of Ways To Paint N 3 Grid](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/discuss/574876/PythonC%2B%2B-Simple-state-compression-DP-O(1)-space)\n\n**Idea**<br>\nAs shown in the first example, there are 12 possible states for a single row and let's name them as `states0, states1, ... states11`. Intuitively we should construct a `dp[i][state]` denoting the number of ways to paint i * 3 grid, with the last row in `state`.<br>\n<img src=\"https://assets.leetcode.com/users/yanrcheng2/image_1586664387.png\" alt=\"image\">\n\n\n\n\nWe first compute the compatibilities of different states. 2 states are compatible if and only if no adjacent grid between them are in the same colour. The full compatibility list are given below.\n\n\n\n\n**Full Compatibility List:**\n\n\n\n\n```\n[\n\t[1, 2, 4, 5, 10], \n\t[0, 3, 6, 8, 11], \n\t[0, 3, 6, 7], \n\t[1, 2, 7, 10], \n\t[0, 6, 8, 9], \n\t[0, 6, 7, 9, 10], \n\t[1, 2, 4, 5, 11], \n\t[2, 3, 5, 11], \n\t[1, 4, 9, 10], \n\t[4, 5, 8, 11], \n\t[0, 3, 5, 8, 11], \n\t[1, 6, 7, 9, 10]\n]\n\n```\n\n\n\nWe then have `dp[i][state] = sum(dp[i - 1][state'])` where `state'` are compatible with `state`\n\n\n\n\n**Complexity**<br>\nTime: `O(n)`<br>\nSpace: `O(1)`\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def numOfWays(self, n: int) -> int:\n        MOD = 1000000007\n        P = ['ryr', 'yry', 'gry', 'ryg', 'yrg', 'grg', 'rgr', 'ygr', 'gyr', 'rgy', 'ygy', 'gyg']\n        nei = [[i for i, x in enumerate(P) if all(a != b for a, b in zip(x, p))] for p in P]\n        \n        dp = [1] * 12\n        for i in range(n - 1):\n            dp = [sum(dp[j] for j in nei[i]) % MOD for i in range(12)]\n        return sum(dp) % MOD\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numOfWays(int n) {\n        vector<vector<int>> compatibility {\n            {1, 2, 4, 5, 10}, \n            {0, 3, 6, 8, 11}, \n            {0, 3, 6, 7}, \n            {1, 2, 7, 10}, \n            {0, 6, 8, 9}, \n            {0, 6, 7, 9, 10}, \n            {1, 2, 4, 5, 11}, \n            {2, 3, 5, 11}, \n            {1, 4, 9, 10}, \n            {4, 5, 8, 11}, \n            {0, 3, 5, 8, 11}, \n            {1, 6, 7, 9, 10}\n        };\n        auto addMod = [&](int a, int b){return (a + b) % 1000000007;};\n        array<int, 12> dp, old;\n        dp.fill(1);\n        while (--n > 0) {\n            old = dp, dp.fill(0);\n            for (int i=0; i < 12; ++i)\n                for (int j=0; j < compatibility[i].size(); ++j)\n                    dp[i] = addMod(dp[i], old[compatibility[i][j]]);\n        }\n        return accumulate(dp.begin(), dp.end(), 0, addMod);\n    }\n};\n\n```\n\n\n","slug":"number-of-ways-to-paint-n-3-grid","published":1,"updated":"2020-08-21T07:57:37.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks4000g4ilu19hh0ahk","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid\">Number Of Ways To Paint N 3 Grid</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/discuss/574876/PythonC%2B%2B-Simple-state-compression-DP-O(1)-space\">Solution</a></p>\n<p><strong>Idea</strong><br><br>As shown in the first example, there are 12 possible states for a single row and let’s name them as <code>states0, states1, ... states11</code>. Intuitively we should construct a <code>dp[i][state]</code> denoting the number of ways to paint i * 3 grid, with the last row in <code>state</code>.<br><br><img src=\"https://assets.leetcode.com/users/yanrcheng2/image_1586664387.png\" alt=\"image\"></p>\n<p>We first compute the compatibilities of different states. 2 states are compatible if and only if no adjacent grid between them are in the same colour. The full compatibility list are given below.</p>\n<p><strong>Full Compatibility List:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [1, 2, 4, 5, 10], </span><br><span class=\"line\">    [0, 3, 6, 8, 11], </span><br><span class=\"line\">    [0, 3, 6, 7], </span><br><span class=\"line\">    [1, 2, 7, 10], </span><br><span class=\"line\">    [0, 6, 8, 9], </span><br><span class=\"line\">    [0, 6, 7, 9, 10], </span><br><span class=\"line\">    [1, 2, 4, 5, 11], </span><br><span class=\"line\">    [2, 3, 5, 11], </span><br><span class=\"line\">    [1, 4, 9, 10], </span><br><span class=\"line\">    [4, 5, 8, 11], </span><br><span class=\"line\">    [0, 3, 5, 8, 11], </span><br><span class=\"line\">    [1, 6, 7, 9, 10]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>We then have <code>dp[i][state] = sum(dp[i - 1][state&#39;])</code> where <code>state&#39;</code> are compatible with <code>state</code></p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(1)</code></p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numOfWays(self, n: int) -&gt; int:</span><br><span class=\"line\">        MOD &#x3D; 1000000007</span><br><span class=\"line\">        P &#x3D; [&#39;ryr&#39;, &#39;yry&#39;, &#39;gry&#39;, &#39;ryg&#39;, &#39;yrg&#39;, &#39;grg&#39;, &#39;rgr&#39;, &#39;ygr&#39;, &#39;gyr&#39;, &#39;rgy&#39;, &#39;ygy&#39;, &#39;gyg&#39;]</span><br><span class=\"line\">        nei &#x3D; [[i for i, x in enumerate(P) if all(a !&#x3D; b for a, b in zip(x, p))] for p in P]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp &#x3D; [1] * 12</span><br><span class=\"line\">        for i in range(n - 1):</span><br><span class=\"line\">            dp &#x3D; [sum(dp[j] for j in nei[i]) % MOD for i in range(12)]</span><br><span class=\"line\">        return sum(dp) % MOD</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numOfWays(int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; compatibility &#123;</span><br><span class=\"line\">            &#123;1, 2, 4, 5, 10&#125;, </span><br><span class=\"line\">            &#123;0, 3, 6, 8, 11&#125;, </span><br><span class=\"line\">            &#123;0, 3, 6, 7&#125;, </span><br><span class=\"line\">            &#123;1, 2, 7, 10&#125;, </span><br><span class=\"line\">            &#123;0, 6, 8, 9&#125;, </span><br><span class=\"line\">            &#123;0, 6, 7, 9, 10&#125;, </span><br><span class=\"line\">            &#123;1, 2, 4, 5, 11&#125;, </span><br><span class=\"line\">            &#123;2, 3, 5, 11&#125;, </span><br><span class=\"line\">            &#123;1, 4, 9, 10&#125;, </span><br><span class=\"line\">            &#123;4, 5, 8, 11&#125;, </span><br><span class=\"line\">            &#123;0, 3, 5, 8, 11&#125;, </span><br><span class=\"line\">            &#123;1, 6, 7, 9, 10&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        auto addMod &#x3D; [&amp;](int a, int b)&#123;return (a + b) % 1000000007;&#125;;</span><br><span class=\"line\">        array&lt;int, 12&gt; dp, old;</span><br><span class=\"line\">        dp.fill(1);</span><br><span class=\"line\">        while (--n &gt; 0) &#123;</span><br><span class=\"line\">            old &#x3D; dp, dp.fill(0);</span><br><span class=\"line\">            for (int i&#x3D;0; i &lt; 12; ++i)</span><br><span class=\"line\">                for (int j&#x3D;0; j &lt; compatibility[i].size(); ++j)</span><br><span class=\"line\">                    dp[i] &#x3D; addMod(dp[i], old[compatibility[i][j]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return accumulate(dp.begin(), dp.end(), 0, addMod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid\">Number Of Ways To Paint N 3 Grid</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/discuss/574876/PythonC%2B%2B-Simple-state-compression-DP-O(1)-space\">Solution</a></p>\n<p><strong>Idea</strong><br><br>As shown in the first example, there are 12 possible states for a single row and let’s name them as <code>states0, states1, ... states11</code>. Intuitively we should construct a <code>dp[i][state]</code> denoting the number of ways to paint i * 3 grid, with the last row in <code>state</code>.<br><br><img src=\"https://assets.leetcode.com/users/yanrcheng2/image_1586664387.png\" alt=\"image\"></p>\n<p>We first compute the compatibilities of different states. 2 states are compatible if and only if no adjacent grid between them are in the same colour. The full compatibility list are given below.</p>\n<p><strong>Full Compatibility List:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    [1, 2, 4, 5, 10], </span><br><span class=\"line\">    [0, 3, 6, 8, 11], </span><br><span class=\"line\">    [0, 3, 6, 7], </span><br><span class=\"line\">    [1, 2, 7, 10], </span><br><span class=\"line\">    [0, 6, 8, 9], </span><br><span class=\"line\">    [0, 6, 7, 9, 10], </span><br><span class=\"line\">    [1, 2, 4, 5, 11], </span><br><span class=\"line\">    [2, 3, 5, 11], </span><br><span class=\"line\">    [1, 4, 9, 10], </span><br><span class=\"line\">    [4, 5, 8, 11], </span><br><span class=\"line\">    [0, 3, 5, 8, 11], </span><br><span class=\"line\">    [1, 6, 7, 9, 10]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>We then have <code>dp[i][state] = sum(dp[i - 1][state&#39;])</code> where <code>state&#39;</code> are compatible with <code>state</code></p>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n)</code><br><br>Space: <code>O(1)</code></p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numOfWays(self, n: int) -&gt; int:</span><br><span class=\"line\">        MOD &#x3D; 1000000007</span><br><span class=\"line\">        P &#x3D; [&#39;ryr&#39;, &#39;yry&#39;, &#39;gry&#39;, &#39;ryg&#39;, &#39;yrg&#39;, &#39;grg&#39;, &#39;rgr&#39;, &#39;ygr&#39;, &#39;gyr&#39;, &#39;rgy&#39;, &#39;ygy&#39;, &#39;gyg&#39;]</span><br><span class=\"line\">        nei &#x3D; [[i for i, x in enumerate(P) if all(a !&#x3D; b for a, b in zip(x, p))] for p in P]</span><br><span class=\"line\">        </span><br><span class=\"line\">        dp &#x3D; [1] * 12</span><br><span class=\"line\">        for i in range(n - 1):</span><br><span class=\"line\">            dp &#x3D; [sum(dp[j] for j in nei[i]) % MOD for i in range(12)]</span><br><span class=\"line\">        return sum(dp) % MOD</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numOfWays(int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; compatibility &#123;</span><br><span class=\"line\">            &#123;1, 2, 4, 5, 10&#125;, </span><br><span class=\"line\">            &#123;0, 3, 6, 8, 11&#125;, </span><br><span class=\"line\">            &#123;0, 3, 6, 7&#125;, </span><br><span class=\"line\">            &#123;1, 2, 7, 10&#125;, </span><br><span class=\"line\">            &#123;0, 6, 8, 9&#125;, </span><br><span class=\"line\">            &#123;0, 6, 7, 9, 10&#125;, </span><br><span class=\"line\">            &#123;1, 2, 4, 5, 11&#125;, </span><br><span class=\"line\">            &#123;2, 3, 5, 11&#125;, </span><br><span class=\"line\">            &#123;1, 4, 9, 10&#125;, </span><br><span class=\"line\">            &#123;4, 5, 8, 11&#125;, </span><br><span class=\"line\">            &#123;0, 3, 5, 8, 11&#125;, </span><br><span class=\"line\">            &#123;1, 6, 7, 9, 10&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        auto addMod &#x3D; [&amp;](int a, int b)&#123;return (a + b) % 1000000007;&#125;;</span><br><span class=\"line\">        array&lt;int, 12&gt; dp, old;</span><br><span class=\"line\">        dp.fill(1);</span><br><span class=\"line\">        while (--n &gt; 0) &#123;</span><br><span class=\"line\">            old &#x3D; dp, dp.fill(0);</span><br><span class=\"line\">            for (int i&#x3D;0; i &lt; 12; ++i)</span><br><span class=\"line\">                for (int j&#x3D;0; j &lt; compatibility[i].size(); ++j)</span><br><span class=\"line\">                    dp[i] &#x3D; addMod(dp[i], old[compatibility[i][j]]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return accumulate(dp.begin(), dp.end(), 0, addMod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Pizza With 3N Slices's Solution","date":"2020-08-21T03:29:21.942Z","_content":"\n**Original Question**: [Pizza With 3N Slices](https://leetcode.com/problems/pizza-with-3n-slices)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/pizza-with-3n-slices/discuss/546442/PythonC%2B%2B-O(n)-space-Easy-DP-with-explanation)\n\n**Idea**<br>\nWe first divide the problem into 2 sub-problem. (since we cannot have slice 0 and slice n at the same time)\n\n\n\n\n1. we choose from pizza [0, ..., n-1] as a linear pizza instead of a circular pizza\n1. we choose from pizza [1, ..., n] as a linear pizza instead of a circular pizza\n\n\n\nWe then track the maximum amount we ate after eating the ith pizza we have in `eat`. There are only 2 possibilities as follows.\n\n\n\n\n1. largest value when encountering the previous slice\n1. current slice + largest value when encountering last second slice\n\n\n\n**Similar Questoins**\n\n\n\n\n- [188. Best Time to Buy and Sell Stock IV](http://https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\n- [213. House Robber II](http://https://leetcode.com/problems/house-robber-ii/)\n\n\n\n**Complexity**<br>\nTime: `O(n^2)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python 3, O(n^2) space and time**\n\n\n\n\n```\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def linear(arr):\n            eat = [[0] + [-math.inf]*n] * 2\n            for x in arr:\n                eat.append([i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)])\n            return max(l[n] for l in eat)\n        return max(linear(slices[1:]), linear(slices[:-1]))\n\n```\n\n\n\n**Python 3, O(n) space**\n\n\n\n\n```\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def linear(arr):\n            eat = collections.deque([[0] + [-math.inf]*n] * 2)\n            res = 0\n            for x in arr:\n                eat += [i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)],\n                eat.popleft()\n                res = max(res, eat[-1][n])\n            return res\n        return max(linear(slices[1:]), linear(slices[:-1]))\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int maxSizeSlices(vector<int>& slices) {\n        int n = (int)slices.size() / 3;\n        auto l1 = vector<int>(slices.begin(), slices.end()-1);\n        auto l2 = vector<int>(slices.begin()+1, slices.end());\n        return max(linear(l1, n), linear(l2, n));\n    }\n    \nprivate:\n    int linear(vector<int>& slices, int n) {\n        vector<vector<int>> eat((int)slices.size()+2, vector<int>(n+1, INT_MIN));\n        int res = INT_MIN;\n        for (int i=0; i<eat.size(); ++i) eat[i][0] = 0;\n        for (int i=2; i<eat.size(); ++i) {\n            for (int j=1; j<n+1; ++j)\n                eat[i][j] = max(eat[i-1][j], eat[i-2][j-1] + slices[i-2]);\n            res = max(eat[i][n], res);\n        }\n        return res;\n    }\n};\n\n```\n\n\n","source":"_posts/pizza-with-3n-slices.md","raw":"---\ntitle: Pizza With 3N Slices's Solution\ndate: 2020-08-21 11:29:21.942942\n---\n\n**Original Question**: [Pizza With 3N Slices](https://leetcode.com/problems/pizza-with-3n-slices)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/pizza-with-3n-slices/discuss/546442/PythonC%2B%2B-O(n)-space-Easy-DP-with-explanation)\n\n**Idea**<br>\nWe first divide the problem into 2 sub-problem. (since we cannot have slice 0 and slice n at the same time)\n\n\n\n\n1. we choose from pizza [0, ..., n-1] as a linear pizza instead of a circular pizza\n1. we choose from pizza [1, ..., n] as a linear pizza instead of a circular pizza\n\n\n\nWe then track the maximum amount we ate after eating the ith pizza we have in `eat`. There are only 2 possibilities as follows.\n\n\n\n\n1. largest value when encountering the previous slice\n1. current slice + largest value when encountering last second slice\n\n\n\n**Similar Questoins**\n\n\n\n\n- [188. Best Time to Buy and Sell Stock IV](http://https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\n- [213. House Robber II](http://https://leetcode.com/problems/house-robber-ii/)\n\n\n\n**Complexity**<br>\nTime: `O(n^2)`<br>\nSpace: `O(n)`\n\n\n\n\n**Python 3, O(n^2) space and time**\n\n\n\n\n```\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def linear(arr):\n            eat = [[0] + [-math.inf]*n] * 2\n            for x in arr:\n                eat.append([i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)])\n            return max(l[n] for l in eat)\n        return max(linear(slices[1:]), linear(slices[:-1]))\n\n```\n\n\n\n**Python 3, O(n) space**\n\n\n\n\n```\nclass Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        n = len(slices) // 3\n        def linear(arr):\n            eat = collections.deque([[0] + [-math.inf]*n] * 2)\n            res = 0\n            for x in arr:\n                eat += [i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)],\n                eat.popleft()\n                res = max(res, eat[-1][n])\n            return res\n        return max(linear(slices[1:]), linear(slices[:-1]))\n\n```\n\n\n\n**C++**\n\n\n\n\n```\nclass Solution {\npublic:\n    int maxSizeSlices(vector<int>& slices) {\n        int n = (int)slices.size() / 3;\n        auto l1 = vector<int>(slices.begin(), slices.end()-1);\n        auto l2 = vector<int>(slices.begin()+1, slices.end());\n        return max(linear(l1, n), linear(l2, n));\n    }\n    \nprivate:\n    int linear(vector<int>& slices, int n) {\n        vector<vector<int>> eat((int)slices.size()+2, vector<int>(n+1, INT_MIN));\n        int res = INT_MIN;\n        for (int i=0; i<eat.size(); ++i) eat[i][0] = 0;\n        for (int i=2; i<eat.size(); ++i) {\n            for (int j=1; j<n+1; ++j)\n                eat[i][j] = max(eat[i-1][j], eat[i-2][j-1] + slices[i-2]);\n            res = max(eat[i][n], res);\n        }\n        return res;\n    }\n};\n\n```\n\n\n","slug":"pizza-with-3n-slices","published":1,"updated":"2020-08-21T07:57:37.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks5000h4ilu1yj83ump","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/pizza-with-3n-slices\">Pizza With 3N Slices</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/pizza-with-3n-slices/discuss/546442/PythonC%2B%2B-O(n)-space-Easy-DP-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>We first divide the problem into 2 sub-problem. (since we cannot have slice 0 and slice n at the same time)</p>\n<ol>\n<li>we choose from pizza [0, …, n-1] as a linear pizza instead of a circular pizza</li>\n<li>we choose from pizza [1, …, n] as a linear pizza instead of a circular pizza</li>\n</ol>\n<p>We then track the maximum amount we ate after eating the ith pizza we have in <code>eat</code>. There are only 2 possibilities as follows.</p>\n<ol>\n<li>largest value when encountering the previous slice</li>\n<li>current slice + largest value when encountering last second slice</li>\n</ol>\n<p><strong>Similar Questoins</strong></p>\n<ul>\n<li><a href=\"http://https//leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. Best Time to Buy and Sell Stock IV</a></li>\n<li><a href=\"http://https//leetcode.com/problems/house-robber-ii/\">213. House Robber II</a></li>\n</ul>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n^2)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python 3, O(n^2) space and time</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxSizeSlices(self, slices: List[int]) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(slices) &#x2F;&#x2F; 3</span><br><span class=\"line\">        def linear(arr):</span><br><span class=\"line\">            eat &#x3D; [[0] + [-math.inf]*n] * 2</span><br><span class=\"line\">            for x in arr:</span><br><span class=\"line\">                eat.append([i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)])</span><br><span class=\"line\">            return max(l[n] for l in eat)</span><br><span class=\"line\">        return max(linear(slices[1:]), linear(slices[:-1]))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, O(n) space</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxSizeSlices(self, slices: List[int]) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(slices) &#x2F;&#x2F; 3</span><br><span class=\"line\">        def linear(arr):</span><br><span class=\"line\">            eat &#x3D; collections.deque([[0] + [-math.inf]*n] * 2)</span><br><span class=\"line\">            res &#x3D; 0</span><br><span class=\"line\">            for x in arr:</span><br><span class=\"line\">                eat +&#x3D; [i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)],</span><br><span class=\"line\">                eat.popleft()</span><br><span class=\"line\">                res &#x3D; max(res, eat[-1][n])</span><br><span class=\"line\">            return res</span><br><span class=\"line\">        return max(linear(slices[1:]), linear(slices[:-1]))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSizeSlices(vector&lt;int&gt;&amp; slices) &#123;</span><br><span class=\"line\">        int n &#x3D; (int)slices.size() &#x2F; 3;</span><br><span class=\"line\">        auto l1 &#x3D; vector&lt;int&gt;(slices.begin(), slices.end()-1);</span><br><span class=\"line\">        auto l2 &#x3D; vector&lt;int&gt;(slices.begin()+1, slices.end());</span><br><span class=\"line\">        return max(linear(l1, n), linear(l2, n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">private:</span><br><span class=\"line\">    int linear(vector&lt;int&gt;&amp; slices, int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; eat((int)slices.size()+2, vector&lt;int&gt;(n+1, INT_MIN));</span><br><span class=\"line\">        int res &#x3D; INT_MIN;</span><br><span class=\"line\">        for (int i&#x3D;0; i&lt;eat.size(); ++i) eat[i][0] &#x3D; 0;</span><br><span class=\"line\">        for (int i&#x3D;2; i&lt;eat.size(); ++i) &#123;</span><br><span class=\"line\">            for (int j&#x3D;1; j&lt;n+1; ++j)</span><br><span class=\"line\">                eat[i][j] &#x3D; max(eat[i-1][j], eat[i-2][j-1] + slices[i-2]);</span><br><span class=\"line\">            res &#x3D; max(eat[i][n], res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/pizza-with-3n-slices\">Pizza With 3N Slices</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/pizza-with-3n-slices/discuss/546442/PythonC%2B%2B-O(n)-space-Easy-DP-with-explanation\">Solution</a></p>\n<p><strong>Idea</strong><br><br>We first divide the problem into 2 sub-problem. (since we cannot have slice 0 and slice n at the same time)</p>\n<ol>\n<li>we choose from pizza [0, …, n-1] as a linear pizza instead of a circular pizza</li>\n<li>we choose from pizza [1, …, n] as a linear pizza instead of a circular pizza</li>\n</ol>\n<p>We then track the maximum amount we ate after eating the ith pizza we have in <code>eat</code>. There are only 2 possibilities as follows.</p>\n<ol>\n<li>largest value when encountering the previous slice</li>\n<li>current slice + largest value when encountering last second slice</li>\n</ol>\n<p><strong>Similar Questoins</strong></p>\n<ul>\n<li><a href=\"http://https//leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. Best Time to Buy and Sell Stock IV</a></li>\n<li><a href=\"http://https//leetcode.com/problems/house-robber-ii/\">213. House Robber II</a></li>\n</ul>\n<p><strong>Complexity</strong><br><br>Time: <code>O(n^2)</code><br><br>Space: <code>O(n)</code></p>\n<p><strong>Python 3, O(n^2) space and time</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxSizeSlices(self, slices: List[int]) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(slices) &#x2F;&#x2F; 3</span><br><span class=\"line\">        def linear(arr):</span><br><span class=\"line\">            eat &#x3D; [[0] + [-math.inf]*n] * 2</span><br><span class=\"line\">            for x in arr:</span><br><span class=\"line\">                eat.append([i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)])</span><br><span class=\"line\">            return max(l[n] for l in eat)</span><br><span class=\"line\">        return max(linear(slices[1:]), linear(slices[:-1]))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3, O(n) space</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def maxSizeSlices(self, slices: List[int]) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(slices) &#x2F;&#x2F; 3</span><br><span class=\"line\">        def linear(arr):</span><br><span class=\"line\">            eat &#x3D; collections.deque([[0] + [-math.inf]*n] * 2)</span><br><span class=\"line\">            res &#x3D; 0</span><br><span class=\"line\">            for x in arr:</span><br><span class=\"line\">                eat +&#x3D; [i and max(eat[-1][i], eat[-2][i-1]+x) for i in range(n+1)],</span><br><span class=\"line\">                eat.popleft()</span><br><span class=\"line\">                res &#x3D; max(res, eat[-1][n])</span><br><span class=\"line\">            return res</span><br><span class=\"line\">        return max(linear(slices[1:]), linear(slices[:-1]))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>C++</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSizeSlices(vector&lt;int&gt;&amp; slices) &#123;</span><br><span class=\"line\">        int n &#x3D; (int)slices.size() &#x2F; 3;</span><br><span class=\"line\">        auto l1 &#x3D; vector&lt;int&gt;(slices.begin(), slices.end()-1);</span><br><span class=\"line\">        auto l2 &#x3D; vector&lt;int&gt;(slices.begin()+1, slices.end());</span><br><span class=\"line\">        return max(linear(l1, n), linear(l2, n));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">private:</span><br><span class=\"line\">    int linear(vector&lt;int&gt;&amp; slices, int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; eat((int)slices.size()+2, vector&lt;int&gt;(n+1, INT_MIN));</span><br><span class=\"line\">        int res &#x3D; INT_MIN;</span><br><span class=\"line\">        for (int i&#x3D;0; i&lt;eat.size(); ++i) eat[i][0] &#x3D; 0;</span><br><span class=\"line\">        for (int i&#x3D;2; i&lt;eat.size(); ++i) &#123;</span><br><span class=\"line\">            for (int j&#x3D;1; j&lt;n+1; ++j)</span><br><span class=\"line\">                eat[i][j] &#x3D; max(eat[i-1][j], eat[i-2][j-1] + slices[i-2]);</span><br><span class=\"line\">            res &#x3D; max(eat[i][n], res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Remove All Adjacent Duplicates In String's Solution","date":"2019-05-20T02:25:00.000Z","_content":"\n**Original Question**: [Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/295660/python-on-linked-list-solution)\n\nNotes:\n\n\n\n\n- Explicitly Breaking the object reference circle in the doubly linked list improves the memory usage by around 4 MB.\n\n```\nclass ListNode:\n    __slots__ = 'val next prev'.split()\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.prev = None\n\nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        self.root = ll = self.list_to_ll(S)\n        while True:\n            if not ll or not ll.next or not ll.next.next: break\n            if ll.next.val == ll.next.next.val:\n                ll.next.next.prev = None # break the hanging nodes, should have used a weak ref\n                ll.next = ll.next.next.next\n                if ll.next:\n                    ll.next.prev = ll\n                ll = ll.prev or ll\n            else: \n                ll = ll.next\n        return self.ll_to_s(self.root)\n    \n    def ll_to_s(self, ll):\n        res = ''\n        while ll:\n            res += ll.val\n            ll = ll.next\n        return res            \n        \n    def list_to_ll(self,l):\n        cur = dummy = ListNode('')\n        for x in l:\n            last = cur\n            cur.next = cur = ListNode(x)\n            cur.prev = last\n        return dummy\n\n```\n\n\n","source":"_posts/remove-all-adjacent-duplicates-in-string.md","raw":"---\ntitle: Remove All Adjacent Duplicates In String's Solution\ndate: 2019-05-20 10:25:00\n---\n\n**Original Question**: [Remove All Adjacent Duplicates In String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/295660/python-on-linked-list-solution)\n\nNotes:\n\n\n\n\n- Explicitly Breaking the object reference circle in the doubly linked list improves the memory usage by around 4 MB.\n\n```\nclass ListNode:\n    __slots__ = 'val next prev'.split()\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.prev = None\n\nclass Solution:\n    def removeDuplicates(self, S: str) -> str:\n        self.root = ll = self.list_to_ll(S)\n        while True:\n            if not ll or not ll.next or not ll.next.next: break\n            if ll.next.val == ll.next.next.val:\n                ll.next.next.prev = None # break the hanging nodes, should have used a weak ref\n                ll.next = ll.next.next.next\n                if ll.next:\n                    ll.next.prev = ll\n                ll = ll.prev or ll\n            else: \n                ll = ll.next\n        return self.ll_to_s(self.root)\n    \n    def ll_to_s(self, ll):\n        res = ''\n        while ll:\n            res += ll.val\n            ll = ll.next\n        return res            \n        \n    def list_to_ll(self,l):\n        cur = dummy = ListNode('')\n        for x in l:\n            last = cur\n            cur.next = cur = ListNode(x)\n            cur.prev = last\n        return dummy\n\n```\n\n\n","slug":"remove-all-adjacent-duplicates-in-string","published":1,"updated":"2020-08-21T07:57:37.056Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks6000i4ilucn0yagi1","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string\">Remove All Adjacent Duplicates In String</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/295660/python-on-linked-list-solution\">Solution</a></p>\n<p>Notes:</p>\n<ul>\n<li>Explicitly Breaking the object reference circle in the doubly linked list improves the memory usage by around 4 MB.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ListNode:</span><br><span class=\"line\">    __slots__ &#x3D; &#39;val next prev&#39;.split()</span><br><span class=\"line\">    def __init__(self, x):</span><br><span class=\"line\">        self.val &#x3D; x</span><br><span class=\"line\">        self.next &#x3D; None</span><br><span class=\"line\">        self.prev &#x3D; None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def removeDuplicates(self, S: str) -&gt; str:</span><br><span class=\"line\">        self.root &#x3D; ll &#x3D; self.list_to_ll(S)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if not ll or not ll.next or not ll.next.next: break</span><br><span class=\"line\">            if ll.next.val &#x3D;&#x3D; ll.next.next.val:</span><br><span class=\"line\">                ll.next.next.prev &#x3D; None # break the hanging nodes, should have used a weak ref</span><br><span class=\"line\">                ll.next &#x3D; ll.next.next.next</span><br><span class=\"line\">                if ll.next:</span><br><span class=\"line\">                    ll.next.prev &#x3D; ll</span><br><span class=\"line\">                ll &#x3D; ll.prev or ll</span><br><span class=\"line\">            else: </span><br><span class=\"line\">                ll &#x3D; ll.next</span><br><span class=\"line\">        return self.ll_to_s(self.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">    def ll_to_s(self, ll):</span><br><span class=\"line\">        res &#x3D; &#39;&#39;</span><br><span class=\"line\">        while ll:</span><br><span class=\"line\">            res +&#x3D; ll.val</span><br><span class=\"line\">            ll &#x3D; ll.next</span><br><span class=\"line\">        return res            </span><br><span class=\"line\">        </span><br><span class=\"line\">    def list_to_ll(self,l):</span><br><span class=\"line\">        cur &#x3D; dummy &#x3D; ListNode(&#39;&#39;)</span><br><span class=\"line\">        for x in l:</span><br><span class=\"line\">            last &#x3D; cur</span><br><span class=\"line\">            cur.next &#x3D; cur &#x3D; ListNode(x)</span><br><span class=\"line\">            cur.prev &#x3D; last</span><br><span class=\"line\">        return dummy</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string\">Remove All Adjacent Duplicates In String</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/295660/python-on-linked-list-solution\">Solution</a></p>\n<p>Notes:</p>\n<ul>\n<li>Explicitly Breaking the object reference circle in the doubly linked list improves the memory usage by around 4 MB.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ListNode:</span><br><span class=\"line\">    __slots__ &#x3D; &#39;val next prev&#39;.split()</span><br><span class=\"line\">    def __init__(self, x):</span><br><span class=\"line\">        self.val &#x3D; x</span><br><span class=\"line\">        self.next &#x3D; None</span><br><span class=\"line\">        self.prev &#x3D; None</span><br><span class=\"line\"></span><br><span class=\"line\">class Solution:</span><br><span class=\"line\">    def removeDuplicates(self, S: str) -&gt; str:</span><br><span class=\"line\">        self.root &#x3D; ll &#x3D; self.list_to_ll(S)</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if not ll or not ll.next or not ll.next.next: break</span><br><span class=\"line\">            if ll.next.val &#x3D;&#x3D; ll.next.next.val:</span><br><span class=\"line\">                ll.next.next.prev &#x3D; None # break the hanging nodes, should have used a weak ref</span><br><span class=\"line\">                ll.next &#x3D; ll.next.next.next</span><br><span class=\"line\">                if ll.next:</span><br><span class=\"line\">                    ll.next.prev &#x3D; ll</span><br><span class=\"line\">                ll &#x3D; ll.prev or ll</span><br><span class=\"line\">            else: </span><br><span class=\"line\">                ll &#x3D; ll.next</span><br><span class=\"line\">        return self.ll_to_s(self.root)</span><br><span class=\"line\">    </span><br><span class=\"line\">    def ll_to_s(self, ll):</span><br><span class=\"line\">        res &#x3D; &#39;&#39;</span><br><span class=\"line\">        while ll:</span><br><span class=\"line\">            res +&#x3D; ll.val</span><br><span class=\"line\">            ll &#x3D; ll.next</span><br><span class=\"line\">        return res            </span><br><span class=\"line\">        </span><br><span class=\"line\">    def list_to_ll(self,l):</span><br><span class=\"line\">        cur &#x3D; dummy &#x3D; ListNode(&#39;&#39;)</span><br><span class=\"line\">        for x in l:</span><br><span class=\"line\">            last &#x3D; cur</span><br><span class=\"line\">            cur.next &#x3D; cur &#x3D; ListNode(x)</span><br><span class=\"line\">            cur.prev &#x3D; last</span><br><span class=\"line\">        return dummy</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Robot Bounded In Circle's Solution","date":"2019-05-16T02:03:00.000Z","_content":"\n**Original Question**: [Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/robot-bounded-in-circle/discuss/293120/python-on-6-line-solution-beats-100)\n\nTricks:\n\n\n\n\n- Complex number suits this question well.\n- Combinations like \"LLLL\", \"RRRR\", \"RL\", \"LR\" does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.\n\n```\nclass Solution:\n    def isRobotBounded(self, ins: str) -> bool:\n        ins = ins.replace('LLLL', '').replace('RRRR', '').replace('RL', '').replace('LR', '')\n        d, p = 1, 0\n        for c in ins:\n            if c == 'G': p += d\n            else: d *= {'L':1j, 'R':-1j}[c]\n        return d.real == 0 or p == 0 or d.real < 0\n\n```\n\n\n","source":"_posts/robot-bounded-in-circle.md","raw":"---\ntitle: Robot Bounded In Circle's Solution\ndate: 2019-05-16 10:03:00\n---\n\n**Original Question**: [Robot Bounded In Circle](https://leetcode.com/problems/robot-bounded-in-circle)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/robot-bounded-in-circle/discuss/293120/python-on-6-line-solution-beats-100)\n\nTricks:\n\n\n\n\n- Complex number suits this question well.\n- Combinations like \"LLLL\", \"RRRR\", \"RL\", \"LR\" does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.\n\n```\nclass Solution:\n    def isRobotBounded(self, ins: str) -> bool:\n        ins = ins.replace('LLLL', '').replace('RRRR', '').replace('RL', '').replace('LR', '')\n        d, p = 1, 0\n        for c in ins:\n            if c == 'G': p += d\n            else: d *= {'L':1j, 'R':-1j}[c]\n        return d.real == 0 or p == 0 or d.real < 0\n\n```\n\n\n","slug":"robot-bounded-in-circle","published":1,"updated":"2020-08-21T07:57:37.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks6000j4ilu3v3e6cv3","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/robot-bounded-in-circle\">Robot Bounded In Circle</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/robot-bounded-in-circle/discuss/293120/python-on-6-line-solution-beats-100\">Solution</a></p>\n<p>Tricks:</p>\n<ul>\n<li>Complex number suits this question well.</li>\n<li>Combinations like “LLLL”, “RRRR”, “RL”, “LR” does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isRobotBounded(self, ins: str) -&gt; bool:</span><br><span class=\"line\">        ins &#x3D; ins.replace(&#39;LLLL&#39;, &#39;&#39;).replace(&#39;RRRR&#39;, &#39;&#39;).replace(&#39;RL&#39;, &#39;&#39;).replace(&#39;LR&#39;, &#39;&#39;)</span><br><span class=\"line\">        d, p &#x3D; 1, 0</span><br><span class=\"line\">        for c in ins:</span><br><span class=\"line\">            if c &#x3D;&#x3D; &#39;G&#39;: p +&#x3D; d</span><br><span class=\"line\">            else: d *&#x3D; &#123;&#39;L&#39;:1j, &#39;R&#39;:-1j&#125;[c]</span><br><span class=\"line\">        return d.real &#x3D;&#x3D; 0 or p &#x3D;&#x3D; 0 or d.real &lt; 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/robot-bounded-in-circle\">Robot Bounded In Circle</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/robot-bounded-in-circle/discuss/293120/python-on-6-line-solution-beats-100\">Solution</a></p>\n<p>Tricks:</p>\n<ul>\n<li>Complex number suits this question well.</li>\n<li>Combinations like “LLLL”, “RRRR”, “RL”, “LR” does not have any effect, removing these combinations are considered very efficient in python, which will lead to a ~15% performance gain.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def isRobotBounded(self, ins: str) -&gt; bool:</span><br><span class=\"line\">        ins &#x3D; ins.replace(&#39;LLLL&#39;, &#39;&#39;).replace(&#39;RRRR&#39;, &#39;&#39;).replace(&#39;RL&#39;, &#39;&#39;).replace(&#39;LR&#39;, &#39;&#39;)</span><br><span class=\"line\">        d, p &#x3D; 1, 0</span><br><span class=\"line\">        for c in ins:</span><br><span class=\"line\">            if c &#x3D;&#x3D; &#39;G&#39;: p +&#x3D; d</span><br><span class=\"line\">            else: d *&#x3D; &#123;&#39;L&#39;:1j, &#39;R&#39;:-1j&#125;[c]</span><br><span class=\"line\">        return d.real &#x3D;&#x3D; 0 or p &#x3D;&#x3D; 0 or d.real &lt; 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"Restore The Array's Solution","date":"2020-04-18T16:04:00.000Z","_content":"\n**Original Question**: [Restore The Array](https://leetcode.com/problems/restore-the-array)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/restore-the-array/discuss/585554/C%2B%2BPython-Simple-DP-with-python)\n\n**Idea**<br>\n`dp[i]` records the **number of possible array that can be printed as a string s[i:]**<br>\nsuppose the length of `s` is `n`.\n\n\n\n\n<li>Base case:\n<ul>\n- we know that there is exactly **one** way to construct an empty string, thus `dp[n] = 1`\n\n- find out all the possible number we can input starting at s[i], thus `dp[i] = sum(dp[j] for all valid j)` where a valid `j` means `1 <= int(s[i:j]) <= k`\n\n\n\n**Complexity**<br>\nTIme: `O(n)`<br>\nSpace: `O(n)`, could be optimised to O(#digits of k)\n\n\n\n\n**C++, without using long**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numberOfArrays(string s, int k) {\n        int n = (int)s.size();\n        vector<int> dp(n + 1, 0);\n        dp[n] = 1; // the base case\n        for (int i=n-1; i>=0; --i) {\n            int num = s[i] - '0', j = i + 1;\n            while (num > 0 && num <= k && j < n + 1) {\n                dp[i] = (dp[i] + dp[j]) % 1000000007;\n\t\t        // a tiny trick to avoid overflow\n                num = (j < n && num <= k / 10) ? 10 * num + (s[j] - '0') : INT_MAX;\n                j++;\n            }\n        }\n        return dp[0];\n    }\n};\n\n```\n\n\n\n**Python 3**\n\n\n\n\n```\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        n = len(s)\n        s = [*map(int, s)] + [math.inf] # for easier implementation\n        dp = [0] * n + [1]\n        for i in range(n - 1, -1, -1):\n            num, j = s[i], i + 1\n            while 1 <= num <= k and j < n + 1:\n                dp[i] = (dp[i] + dp[j]) % 1000000007\n                num = 10 * num + s[j]\n                j += 1\n        return dp[0]\n\n```\n\n\n","source":"_posts/restore-the-array.md","raw":"---\ntitle: Restore The Array's Solution\ndate: 2020-04-19 00:04:00\n---\n\n**Original Question**: [Restore The Array](https://leetcode.com/problems/restore-the-array)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/restore-the-array/discuss/585554/C%2B%2BPython-Simple-DP-with-python)\n\n**Idea**<br>\n`dp[i]` records the **number of possible array that can be printed as a string s[i:]**<br>\nsuppose the length of `s` is `n`.\n\n\n\n\n<li>Base case:\n<ul>\n- we know that there is exactly **one** way to construct an empty string, thus `dp[n] = 1`\n\n- find out all the possible number we can input starting at s[i], thus `dp[i] = sum(dp[j] for all valid j)` where a valid `j` means `1 <= int(s[i:j]) <= k`\n\n\n\n**Complexity**<br>\nTIme: `O(n)`<br>\nSpace: `O(n)`, could be optimised to O(#digits of k)\n\n\n\n\n**C++, without using long**\n\n\n\n\n```\nclass Solution {\npublic:\n    int numberOfArrays(string s, int k) {\n        int n = (int)s.size();\n        vector<int> dp(n + 1, 0);\n        dp[n] = 1; // the base case\n        for (int i=n-1; i>=0; --i) {\n            int num = s[i] - '0', j = i + 1;\n            while (num > 0 && num <= k && j < n + 1) {\n                dp[i] = (dp[i] + dp[j]) % 1000000007;\n\t\t        // a tiny trick to avoid overflow\n                num = (j < n && num <= k / 10) ? 10 * num + (s[j] - '0') : INT_MAX;\n                j++;\n            }\n        }\n        return dp[0];\n    }\n};\n\n```\n\n\n\n**Python 3**\n\n\n\n\n```\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        n = len(s)\n        s = [*map(int, s)] + [math.inf] # for easier implementation\n        dp = [0] * n + [1]\n        for i in range(n - 1, -1, -1):\n            num, j = s[i], i + 1\n            while 1 <= num <= k and j < n + 1:\n                dp[i] = (dp[i] + dp[j]) % 1000000007\n                num = 10 * num + s[j]\n                j += 1\n        return dp[0]\n\n```\n\n\n","slug":"restore-the-array","published":1,"updated":"2020-08-21T07:57:37.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks7000k4ilu2db296un","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/restore-the-array\">Restore The Array</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/restore-the-array/discuss/585554/C%2B%2BPython-Simple-DP-with-python\">Solution</a></p>\n<p><strong>Idea</strong><br><br><code>dp[i]</code> records the <strong>number of possible array that can be printed as a string s[i:]</strong><br><br>suppose the length of <code>s</code> is <code>n</code>.</p>\n<li>Base case:\n<ul>\n- we know that there is exactly **one** way to construct an empty string, thus `dp[n] = 1`\n\n<ul>\n<li>find out all the possible number we can input starting at s[i], thus <code>dp[i] = sum(dp[j] for all valid j)</code> where a valid <code>j</code> means <code>1 &lt;= int(s[i:j]) &lt;= k</code></li>\n</ul>\n<p><strong>Complexity</strong><br><br>TIme: <code>O(n)</code><br><br>Space: <code>O(n)</code>, could be optimised to O(#digits of k)</p>\n<p><strong>C++, without using long</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numberOfArrays(string s, int k) &#123;</span><br><span class=\"line\">        int n &#x3D; (int)s.size();</span><br><span class=\"line\">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class=\"line\">        dp[n] &#x3D; 1; &#x2F;&#x2F; the base case</span><br><span class=\"line\">        for (int i&#x3D;n-1; i&gt;&#x3D;0; --i) &#123;</span><br><span class=\"line\">            int num &#x3D; s[i] - &#39;0&#39;, j &#x3D; i + 1;</span><br><span class=\"line\">            while (num &gt; 0 &amp;&amp; num &lt;&#x3D; k &amp;&amp; j &lt; n + 1) &#123;</span><br><span class=\"line\">                dp[i] &#x3D; (dp[i] + dp[j]) % 1000000007;</span><br><span class=\"line\">                &#x2F;&#x2F; a tiny trick to avoid overflow</span><br><span class=\"line\">                num &#x3D; (j &lt; n &amp;&amp; num &lt;&#x3D; k &#x2F; 10) ? 10 * num + (s[j] - &#39;0&#39;) : INT_MAX;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numberOfArrays(self, s: str, k: int) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(s)</span><br><span class=\"line\">        s &#x3D; [*map(int, s)] + [math.inf] # for easier implementation</span><br><span class=\"line\">        dp &#x3D; [0] * n + [1]</span><br><span class=\"line\">        for i in range(n - 1, -1, -1):</span><br><span class=\"line\">            num, j &#x3D; s[i], i + 1</span><br><span class=\"line\">            while 1 &lt;&#x3D; num &lt;&#x3D; k and j &lt; n + 1:</span><br><span class=\"line\">                dp[i] &#x3D; (dp[i] + dp[j]) % 1000000007</span><br><span class=\"line\">                num &#x3D; 10 * num + s[j]</span><br><span class=\"line\">                j +&#x3D; 1</span><br><span class=\"line\">        return dp[0]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/restore-the-array\">Restore The Array</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/restore-the-array/discuss/585554/C%2B%2BPython-Simple-DP-with-python\">Solution</a></p>\n<p><strong>Idea</strong><br><br><code>dp[i]</code> records the <strong>number of possible array that can be printed as a string s[i:]</strong><br><br>suppose the length of <code>s</code> is <code>n</code>.</p>\n<li>Base case:\n<ul>\n- we know that there is exactly **one** way to construct an empty string, thus `dp[n] = 1`\n\n<ul>\n<li>find out all the possible number we can input starting at s[i], thus <code>dp[i] = sum(dp[j] for all valid j)</code> where a valid <code>j</code> means <code>1 &lt;= int(s[i:j]) &lt;= k</code></li>\n</ul>\n<p><strong>Complexity</strong><br><br>TIme: <code>O(n)</code><br><br>Space: <code>O(n)</code>, could be optimised to O(#digits of k)</p>\n<p><strong>C++, without using long</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int numberOfArrays(string s, int k) &#123;</span><br><span class=\"line\">        int n &#x3D; (int)s.size();</span><br><span class=\"line\">        vector&lt;int&gt; dp(n + 1, 0);</span><br><span class=\"line\">        dp[n] &#x3D; 1; &#x2F;&#x2F; the base case</span><br><span class=\"line\">        for (int i&#x3D;n-1; i&gt;&#x3D;0; --i) &#123;</span><br><span class=\"line\">            int num &#x3D; s[i] - &#39;0&#39;, j &#x3D; i + 1;</span><br><span class=\"line\">            while (num &gt; 0 &amp;&amp; num &lt;&#x3D; k &amp;&amp; j &lt; n + 1) &#123;</span><br><span class=\"line\">                dp[i] &#x3D; (dp[i] + dp[j]) % 1000000007;</span><br><span class=\"line\">                &#x2F;&#x2F; a tiny trick to avoid overflow</span><br><span class=\"line\">                num &#x3D; (j &lt; n &amp;&amp; num &lt;&#x3D; k &#x2F; 10) ? 10 * num + (s[j] - &#39;0&#39;) : INT_MAX;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python 3</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def numberOfArrays(self, s: str, k: int) -&gt; int:</span><br><span class=\"line\">        n &#x3D; len(s)</span><br><span class=\"line\">        s &#x3D; [*map(int, s)] + [math.inf] # for easier implementation</span><br><span class=\"line\">        dp &#x3D; [0] * n + [1]</span><br><span class=\"line\">        for i in range(n - 1, -1, -1):</span><br><span class=\"line\">            num, j &#x3D; s[i], i + 1</span><br><span class=\"line\">            while 1 &lt;&#x3D; num &lt;&#x3D; k and j &lt; n + 1:</span><br><span class=\"line\">                dp[i] &#x3D; (dp[i] + dp[j]) % 1000000007</span><br><span class=\"line\">                num &#x3D; 10 * num + s[j]</span><br><span class=\"line\">                j +&#x3D; 1</span><br><span class=\"line\">        return dp[0]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"The K Th Lexicographical String Of All Happy Strings Of Length N's Solution","date":"2020-04-18T16:01:00.000Z","_content":"\n**Original Question**: [The K Th Lexicographical String Of All Happy Strings Of Length N](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585561/Python-7-line-DFS-with-yield)\n\n**Idea**<br>\nThe property of DFS helps us iterate through all the possibilities in ascending order automatically. All we need to do is to output the kth result.\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def generate(prev):\n            if len(prev) == n:\n                yield prev; return\n            yield from (res for c in 'abc' if not prev or c != prev[-1] for res in generate(prev + c))\n            \n        for i, res in enumerate(generate(''), 1):            \n            if i == k: return res\n        return ''     \n\n```\n\n\n\n**Python, more readable**\n\n\n\n\n```\nclass Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def generate(prev):\n            if len(prev) == n:\n                yield prev\n                return\n            for c in 'abc':\n                if not prev or c != prev[-1]:\n                    yield from generate(prev + c)\n            \n        for i, res in enumerate(generate(''), 1):            \n            if i == k:\n                return res\n        return ''  \n\n```\n\n\n","source":"_posts/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.md","raw":"---\ntitle: The K Th Lexicographical String Of All Happy Strings Of Length N's Solution\ndate: 2020-04-19 00:01:00\n---\n\n**Original Question**: [The K Th Lexicographical String Of All Happy Strings Of Length N](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n)\n**Original Solution Post**: [Solution](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585561/Python-7-line-DFS-with-yield)\n\n**Idea**<br>\nThe property of DFS helps us iterate through all the possibilities in ascending order automatically. All we need to do is to output the kth result.\n\n\n\n\n**Python**\n\n\n\n\n```\nclass Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def generate(prev):\n            if len(prev) == n:\n                yield prev; return\n            yield from (res for c in 'abc' if not prev or c != prev[-1] for res in generate(prev + c))\n            \n        for i, res in enumerate(generate(''), 1):            \n            if i == k: return res\n        return ''     \n\n```\n\n\n\n**Python, more readable**\n\n\n\n\n```\nclass Solution:\n    def getHappyString(self, n: int, k: int) -> str:\n        def generate(prev):\n            if len(prev) == n:\n                yield prev\n                return\n            for c in 'abc':\n                if not prev or c != prev[-1]:\n                    yield from generate(prev + c)\n            \n        for i, res in enumerate(generate(''), 1):            \n            if i == k:\n                return res\n        return ''  \n\n```\n\n\n","slug":"the-k-th-lexicographical-string-of-all-happy-strings-of-length-n","published":1,"updated":"2020-08-21T07:57:37.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cke3xyks7000l4ilu736ra064","content":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n\">The K Th Lexicographical String Of All Happy Strings Of Length N</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585561/Python-7-line-DFS-with-yield\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The property of DFS helps us iterate through all the possibilities in ascending order automatically. All we need to do is to output the kth result.</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def getHappyString(self, n: int, k: int) -&gt; str:</span><br><span class=\"line\">        def generate(prev):</span><br><span class=\"line\">            if len(prev) &#x3D;&#x3D; n:</span><br><span class=\"line\">                yield prev; return</span><br><span class=\"line\">            yield from (res for c in &#39;abc&#39; if not prev or c !&#x3D; prev[-1] for res in generate(prev + c))</span><br><span class=\"line\">            </span><br><span class=\"line\">        for i, res in enumerate(generate(&#39;&#39;), 1):            </span><br><span class=\"line\">            if i &#x3D;&#x3D; k: return res</span><br><span class=\"line\">        return &#39;&#39;     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python, more readable</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def getHappyString(self, n: int, k: int) -&gt; str:</span><br><span class=\"line\">        def generate(prev):</span><br><span class=\"line\">            if len(prev) &#x3D;&#x3D; n:</span><br><span class=\"line\">                yield prev</span><br><span class=\"line\">                return</span><br><span class=\"line\">            for c in &#39;abc&#39;:</span><br><span class=\"line\">                if not prev or c !&#x3D; prev[-1]:</span><br><span class=\"line\">                    yield from generate(prev + c)</span><br><span class=\"line\">            </span><br><span class=\"line\">        for i, res in enumerate(generate(&#39;&#39;), 1):            </span><br><span class=\"line\">            if i &#x3D;&#x3D; k:</span><br><span class=\"line\">                return res</span><br><span class=\"line\">        return &#39;&#39;  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Original Question</strong>: <a href=\"https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n\">The K Th Lexicographical String Of All Happy Strings Of Length N</a><br><strong>Original Solution Post</strong>: <a href=\"https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/discuss/585561/Python-7-line-DFS-with-yield\">Solution</a></p>\n<p><strong>Idea</strong><br><br>The property of DFS helps us iterate through all the possibilities in ascending order automatically. All we need to do is to output the kth result.</p>\n<p><strong>Python</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def getHappyString(self, n: int, k: int) -&gt; str:</span><br><span class=\"line\">        def generate(prev):</span><br><span class=\"line\">            if len(prev) &#x3D;&#x3D; n:</span><br><span class=\"line\">                yield prev; return</span><br><span class=\"line\">            yield from (res for c in &#39;abc&#39; if not prev or c !&#x3D; prev[-1] for res in generate(prev + c))</span><br><span class=\"line\">            </span><br><span class=\"line\">        for i, res in enumerate(generate(&#39;&#39;), 1):            </span><br><span class=\"line\">            if i &#x3D;&#x3D; k: return res</span><br><span class=\"line\">        return &#39;&#39;     </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>Python, more readable</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution:</span><br><span class=\"line\">    def getHappyString(self, n: int, k: int) -&gt; str:</span><br><span class=\"line\">        def generate(prev):</span><br><span class=\"line\">            if len(prev) &#x3D;&#x3D; n:</span><br><span class=\"line\">                yield prev</span><br><span class=\"line\">                return</span><br><span class=\"line\">            for c in &#39;abc&#39;:</span><br><span class=\"line\">                if not prev or c !&#x3D; prev[-1]:</span><br><span class=\"line\">                    yield from generate(prev + c)</span><br><span class=\"line\">            </span><br><span class=\"line\">        for i, res in enumerate(generate(&#39;&#39;), 1):            </span><br><span class=\"line\">            if i &#x3D;&#x3D; k:</span><br><span class=\"line\">                return res</span><br><span class=\"line\">        return &#39;&#39;  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}